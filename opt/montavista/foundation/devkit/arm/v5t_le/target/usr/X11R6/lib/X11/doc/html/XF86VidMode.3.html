
<!--
  $XdotOrg: xc/programs/Xserver/hw/xfree86/doc/man/XF86VM.man,v 1.2 2004/04/23 19:23:08 eich Exp $
   $TOG: XF86VM.man /main/6 1997/07/19 10:30:39 kaleb $
   
   
   
   
   Copyright (c) 1996  Joe Moss, The XFree86 Project
   $XFree86: xc/programs/Xserver/hw/xfree86/doc/man/XF86VM.man,v 3.14 2003/10/02 13:29:56 eich Exp $
   
 
-->
<!-- manual page source format generated by PolyglotMan v3.0.8+X.Org, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>XF86VIDMODE(3x) manual page</title>
</head>
<body bgcolor='#efefef' text='black' link='blue' vlink='#551A8B' alink='red'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
XF86VidModeQueryExtension, XF86VidModeQueryVersion, XF86VidModeSetClientVersion,
XF86VidModeGetModeLine, XF86VidModeGetAllModeLines, XF86VidModeDeleteModeLine,
XF86VidModeModModeLine, XF86VidModeValidateModeLine, XF86VidModeSwitchMode,
XF86VidModeSwitchToMode, XF86VidModeLockModeSwitch, XF86VidModeGetMonitor,
XF86VidModeGetViewPort, XF86VidModeSetViewPort, XF86VidModeGetDotClocks,
XF86VidModeGetGamma, XF86VidModeSetGamma, XF86VidModeGetGammaRamp, XF86VidModeSetGammaRamp,
XF86VidModeGetGammaRampSize, XF86VidModeGetPermissions - Extension libary
for the XFree86-VidMode X extension 
<h2><a name='sect1' href='#toc1'>Syntax</a></h2>
<br>
<pre>#include &lt;X11/extensions/xf86vmode.h&gt;

Bool XF86VidModeQueryExtension(
    Display *<i>display</i>,
    int *<i>event_base_return</i>,
    int *<i>error_base_return</i>);

Bool XF86VidModeQueryVersion(
    Display *<i>display</i>,
    int *<i>major_version_return</i>,
    int *<i>minor_version_return</i>);

Bool XF86VidModeSetClientVersion(
    Display *<i>display</i>);

Bool XF86VidModeGetModeLine(
    Display *<i>display</i>,
    int <i>screen</i>,
    int *<i>dotclock_return</i>,
    XF86VidModeModeLine *<i>modeline</i>);

Bool XF86VidModeGetAllModeLines(
    Display *<i>display</i>,
    int <i>screen</i>,
    int *<i>modecount_return</i>,
    XF86VidModeModeInfo ***<i>modesinfo</i>);

Bool XF86VidModeDeleteModeLine(
    Display *<i>display</i>,
    int <i>screen</i>,
    XF86VidModeModeInfo *<i>modeline</i>);

Bool XF86VidModeModModeLine(
    Display *<i>display</i>,
    int <i>screen</i>,
    XF86VidModeModeLine *<i>modeline</i>);

Status XF86VidModeValidateModeLine(
    Display *<i>display</i>,
    int <i>screen</i>,
    XF86VidModeModeLine *<i>modeline</i>);

Bool XF86VidModeSwitchMode(
    Display *<i>display</i>,
    int <i>screen</i>,
    int <i>zoom</i>);

Bool XF86VidModeSwitchToMode(
    Display *<i>display</i>,
    int <i>screen</i>,
    XF86VidModeModeInfo *<i>modeline</i>);

Bool XF86VidModeLockModeSwitch(
    Display *<i>display</i>,
    int <i>screen</i>,
    int <i>lock</i>);

Bool XF86VidModeGetMonitor(
    Display *<i>display</i>,
    int <i>screen</i>,
    XF86VidModeMonitor *<i>monitor</i>);

Bool XF86VidModeGetViewPort(
    Display *<i>display</i>,
    int <i>screen</i>,
    int *<i>x_return</i>,
    int *<i>y_return</i>);

Bool XF86VidModeSetViewPort(
    Display *<i>display</i>,
    int <i>screen</i>,
    int <i>x</i>,
    int <i>y</i>);

XF86VidModeGetDotClocks(
    Display *<i>display</i>,
    int <i>screen</i>,
    int *<i>flags return</i>,
    int *<i>number of clocks return</i>,
    int *<i>max dot clock return</i>,
    int **<i>clocks return</i>);

XF86VidModeGetGamma(
    Display *<i>display</i>,
    int <i>screen</i>,
    XF86VidModeGamma *<i>Gamma</i>);

XF86VidModeSetGamma(
    Display *<i>display</i>,
    int <i>screen</i>,
    XF86VidModeGamma *<i>Gamma</i>);

XF86VidModeGetGammaRamp(
    Display *<i>display</i>,
    int <i>screen</i>,
    int <i>size</i>,
    unsigned short *<i>red array</i>,
    unsigned short *<i>green array</i>,
    unsigned short *<i>blue array</i>);

XF86VidModeSetGammaRamp(
    Display *<i>display</i>,
    int <i>screen</i>,
    int <i>size</i>,
    unsigned short *<i>red array</i>,
    unsigned short *<i>green array</i>,
    unsigned short *<i>blue array</i>);

XF86VidModeGetGammaRampSize(
    Display *<i>display</i>,
    int <i>screen</i>,
    int *<i>size</i>);
</pre>
<h2><a name='sect2' href='#toc2'>Arguments</a></h2>

<dl>

<dt><i>display</i></dt>
<dd>Specifies the connection to the X server. </dd>

<dt><i>screen</i></dt>
<dd>Specifies
which screen number the setting apply to. </dd>

<dt><i>event_base_return</i></dt>
<dd>Returns the base
event number for the extension. </dd>

<dt><i>error_base_return</i></dt>
<dd>Returns the base error
number for the extension. </dd>

<dt><i>major_version_return</i></dt>
<dd>Returns the major version
number of the extension. </dd>

<dt><i>minor_version_return</i></dt>
<dd>Returns the minor version number
of the extension. </dd>

<dt><i>dotclock_return</i></dt>
<dd>Returns the clock for the mode line. </dd>

<dt><i>modecount_return</i></dt>
<dd>Returns
the number of video modes available in the server. </dd>

<dt><i>zoom</i></dt>
<dd>If greater than zero,
indicates that the server should switch to the next mode, otherwise switch
to the previous mode. </dd>

<dt><i>lock</i></dt>
<dd>Indicates that mode switching should be locked,
if non-zero. </dd>

<dt><i>modeline</i></dt>
<dd>Specifies or returns the timing values for a video mode.
</dd>

<dt><i>modesinfo</i></dt>
<dd>Returns the timing values and dotclocks for all of the available
video modes. </dd>

<dt><i>monitor</i></dt>
<dd>Returns information about the monitor. </dd>

<dt><i>x</i></dt>
<dd>Specifies the
desired X location for the viewport. </dd>

<dt><i>x_return</i></dt>
<dd>Returns the current X location
of the viewport. </dd>

<dt><i>y</i></dt>
<dd>Specifies the desired Y location for the viewport. </dd>

<dt><i>y_return</i></dt>
<dd>Returns
the current Y location of the viewport. </dd>
</dl>

<h2><a name='sect3' href='#toc3'>Structures</a></h2>
<br>
<pre><i>Video Mode Settings:</i>
typedef struct {
    unsigned short<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;hdisplay;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Number of display pixels horizontally */
    unsigned short<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;hsyncstart;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Horizontal sync start */
    unsigned short<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;hsyncend;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Horizontal sync end */
    unsigned short<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;htotal;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Total horizontal pixels */
    unsigned short<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;vdisplay;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Number of display pixels vertically */
    unsigned short<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;vsyncstart;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Vertical sync start */
    unsigned short<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;vsyncend;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Vertical sync start */
    unsigned short<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;vtotal;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Total vertical pixels */
    unsigned int<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;flags;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Mode flags */
    int<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;privsize;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Size of private */
    INT32<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;*private;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Server privates */
} XF86VidModeModeLine;

typedef struct {
    unsigned int<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;dotclock;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Pixel clock */
    unsigned short<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;hdisplay;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Number of display pixels horizontally */
    unsigned short<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;hsyncstart;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Horizontal sync start */
    unsigned short<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;hsyncend;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Horizontal sync end */
    unsigned short<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;htotal;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Total horizontal pixels */
    unsigned short<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;vdisplay;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Number of display pixels vertically */
    unsigned short<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;vsyncstart;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Vertical sync start */
    unsigned short<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;vsyncend;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Vertical sync start */
    unsigned short<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;vtotal;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Total vertical pixels */
    unsigned int<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;flags;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Mode flags */
    int<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;privsize;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Size of private */
    INT32<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;*private;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Server privates */
} XF86VidModeModeInfo;
<i>Monitor information:</i>
typedef struct {
    char*<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;vendor;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Name of manufacturer */
    char*<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;model;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Model name */
    float<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;EMPTY;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* unused, for backward compatibility */
    unsigned char<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;nhsync;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Number of horiz sync ranges */
    XF86VidModeSyncRange*<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;hsync;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Horizontal sync ranges */
    unsigned char<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;nvsync;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Number of vert sync ranges */
    XF86VidModeSyncRange*<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;vsync;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Vertical sync ranges */
} XF86VidModeMonitor;

typedef struct {
    float<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;hi;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Top of range */
    float<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;lo;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Bottom of range */
} XF86VidModeSyncRange;

typedef struct {
    int type;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* of event */
    unsigned long serial;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* # of last request processed by server */
    Bool send_event;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* true if this came from a SendEvent req */
    Display *display;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Display the event was read from */
    Window root;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* root window of event screen */
    int state;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* What happened */
    int kind;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* What happened */
    Bool forced;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* extents of new region */
    Time time;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* event timestamp */
} XF86VidModeNotifyEvent;

typedef struct {
    float red;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Red Gamma value */
    float green;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Green Gamma value */
    float blue;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* Blue Gamma value */
} XF86VidModeGamma;
</pre>
<h2><a name='sect4' href='#toc4'>Description</a></h2>
These functions provide an interface to the server extension
<i>XFree86-VidModeExtension</i> which allows the video modes to be queried and
adjusted dynamically and mode switching to be controlled. Applications that
use these functions must be linked with <i>-lXxf86vm</i>   
<h3><a name='sect5' href='#toc5'>Modeline Functions</a></h3>
The
<i>XF86VidModeGetModeLine</i>   function is used to query the settings for the
currently selected video mode.  The calling program should pass a pointer
to a  <i>XF86VidModeModeLine</i>   structure that it has already allocated.  The
function fills in the fields of the structure. <p>
If there are any server private
values (currently only applicable to the S3 server) the function will allocate
storage for them. Therefore, if the <i>privsize</i>   field is non-zero, the calling
program should call <a href='Xfree.p.html'><i>Xfree(private)</i></a>
   to free the storage. <p>
<i>XF86VidModeGetAllModeLines</i>
  returns the settings for all video modes. The calling program supplies
the address of a pointer which will be set by the function to point to
an array of <i>XF86VidModeModeInfo</i>   structures.  The memory occupied by the
array is dynamically allocated by the <i>XF86VidModeGetAllModeLines</i>   function
and should be freed by the caller. The first element of the array corresponds
to the current video mode. <p>
The <i>XF86VidModeModModeLine</i>   function can be
used to change the settings of the current video mode provided the requested
settings are valid (e.g. they don't exceed the capabilities of the monitor).
<p>
Modes can be deleted with the <i>XF86VidModeDeleteModeLine</i>   function.  The
specified mode must match an existing mode. To be considered a match, all
of the fields of the given <i>XF86VidModeModeInfo</i>   structure must match,
except the <i>privsize</i>   and <i>private</i>   fields. If the mode to be deleted is
the current mode, a mode switch to the next mode will occur first.  The
last remaining mode can not be deleted. <p>
The validity of a mode can be checked
with the <i>XF86VidModeValidateModeLine</i>   function. If the specified mode can
be used by the server (i.e. meets all the constraints placed upon a mode
by the combination of the server, card, and monitor) the function returns
<i>MODE_OK</i>,   otherwise it returns a value indicating the reason why the mode
is invalid (as defined in <i>xf86.h</i>) 
<h3><a name='sect6' href='#toc6'>Mode Switch Functions</a></h3>
When the function
<i>XF86VidModeSwitchMode</i>   is called, the server will change the video mode
to next (or previous) video mode. The <i>XF86VidModeSwitchToMode</i>   function
can be used to switch directly to the specified mode. Matching is as specified
in the description of the <i>XF86VidModeAddModeLine</i>   function above. The <i>XF86VidModeLockModeSwitch</i>
  function can be used to allow or disallow mode switching whether the
request to switch modes comes from a call to the <i>XF86VidModeSwitchMode</i>
  or <i>XF86VidModeSwitchToMode</i>   functions or from one of the mode switch
key sequences. <p>
Note: Because of the asynchronous nature of the X protocol,
a call to  <i>XFlush</i>   is needed if the application wants to see the mode
change immediately. To be informed of the execution status of the request,
a custom error handler should be installed using <i>XSetErrorHandler</i>   before
calling the mode switching function.  
<h3><a name='sect7' href='#toc7'>Monitor Functions</a></h3>
Information known
to the server about the monitor is returned by the <i>XF86VidModeGetMonitor</i>
  function.  The <i>hsync</i>   and <i>vsync</i>   fields each point to an array of <i>XF86VidModeSyncRange</i>
  structures.  The arrays contain <i>nhsync</i>   and <i>nvsync</i>   elements, respectively.
The <i>hi</i>   and <i>low</i>   values will be equal if a discreate value was given
in the <i>XF86Config</i>   file. <p>
The <i>vendor</i>,   <i>model</i>,   <i>hsync</i>,   and <i>vsync</i>   fields
point to dynamically allocated storage that should be freed by the caller.

<h3><a name='sect8' href='#toc8'>Viewport Functions</a></h3>
The <i>XF86VidModeGetViewPort</i>   and <i>XF86VidModeSetViewPort</i>
  functions can be used to, respectively, query and change the location
of the upper left corner of the viewport into the virtual screen. 
<h3><a name='sect9' href='#toc9'>Other
Functions</a></h3>
The <i>XF86VidModeQueryVersion</i>   function can be used to determine
the version of the extension built into the server. <p>
The function <i>XF86VidModeQueryExtension</i>
  returns the lowest numbered error and event values assigned to the extension.

<h2><a name='sect10' href='#toc10'>Bugs</a></h2>
The XF86VidModeSetClientVersion, XF86VidModeGetDotClocks, XF86VidModeGetGamma,
XF86VidModeSetGamma, XF86VidModeSetGammaRamp, XF86VidModeGetGammaRamp,
XF86VidModeGetGammaRampSize, and XF86VidModeGetPermissions functions need
to be documented.  In the meantime, check the source code for information
about how to use them. 
<h2><a name='sect11' href='#toc11'>See Also</a></h2>
<a href='Xorg.3.html'>Xorg(3x)</a>
, <a href='xorg.conf.5.html'>xorg.conf(5x)</a>
, <a href='XFlush.3.html'>XFlush(3x)</a>
, <a href='XSetErrorHandler.3.html'>XSetErrorHandler(3x)</a>
,
<a href='xvidtune.3.html'>xvidtune(3x)</a>
 
<h2><a name='sect12' href='#toc12'>Authors</a></h2>
Kaleb Keithley, Jon Tombs, David Dawes, and Joe Moss
<p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Syntax</a></li>
<li><a name='toc2' href='#sect2'>Arguments</a></li>
<li><a name='toc3' href='#sect3'>Structures</a></li>
<li><a name='toc4' href='#sect4'>Description</a></li>
<ul>
<li><a name='toc5' href='#sect5'>Modeline Functions</a></li>
<li><a name='toc6' href='#sect6'>Mode Switch Functions</a></li>
<li><a name='toc7' href='#sect7'>Monitor Functions</a></li>
<li><a name='toc8' href='#sect8'>Viewport Functions</a></li>
<li><a name='toc9' href='#sect9'>Other Functions</a></li>
</ul>
<li><a name='toc10' href='#sect10'>Bugs</a></li>
<li><a name='toc11' href='#sect11'>See Also</a></li>
<li><a name='toc12' href='#sect12'>Authors</a></li>
</ul>
</body>
</html>
