<html lang="en">
<head>
<title>POSIX Semaphores - The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU C Library">
<meta name="generator" content="makeinfo 4.7">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="POSIX-Threads.html#POSIX-Threads" title="POSIX Threads">
<link rel="prev" href="Condition-Variables.html#Condition-Variables" title="Condition Variables">
<link rel="next" href="Thread_002dSpecific-Data.html#Thread_002dSpecific-Data" title="Thread-Specific Data">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc { font-variant:small-caps }
  span.roman { font-family: serif; font-weight: normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="POSIX-Semaphores"></a>Next:&nbsp;<a rel="next" accesskey="n" href="Thread_002dSpecific-Data.html#Thread_002dSpecific-Data">Thread-Specific Data</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Condition-Variables.html#Condition-Variables">Condition Variables</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="POSIX-Threads.html#POSIX-Threads">POSIX Threads</a>
<hr><br>
</div>

<h3 class="section">34.7 POSIX Semaphores</h3>

<p><a name="index-SEM_005fVALUE_005fMAX-3745"></a>Semaphores are counters for resources shared between threads. The
basic operations on semaphores are: increment the counter atomically,
and wait until the counter is non-null and decrement it atomically.

   <p>Semaphores have a maximum value past which they cannot be incremented. 
The macro <code>SEM_VALUE_MAX</code> is defined to be this maximum value.  In
the GNU C library, <code>SEM_VALUE_MAX</code> is equal to <code>INT_MAX</code>
(see <a href="Range-of-Type.html#Range-of-Type">Range of Type</a>), but it may be much smaller on other systems.

   <p>The pthreads library implements POSIX 1003.1b semaphores.  These should
not be confused with System V semaphores (<code>ipc</code>, <code>semctl</code> and
<code>semop</code>). 
<!-- !!! SysV IPC is not doc'd at all in our manual -->

   <p>All the semaphore functions and macros are defined in <span class="file">semaphore.h</span>.

<!-- semaphore.h -->
<!-- POSIX -->
<div class="defun">
&mdash; Function: int <b>sem_init</b> (<var>sem_t *sem, int pshared, unsigned int value</var>)<var><a name="index-sem_005finit-3746"></a></var><br>
<blockquote><p><code>sem_init</code> initializes the semaphore object pointed to by
<var>sem</var>. The count associated with the semaphore is set initially to
<var>value</var>. The <var>pshared</var> argument indicates whether the semaphore
is local to the current process (<var>pshared</var> is zero) or is to be
shared between several processes (<var>pshared</var> is not zero).

        <p>On success <code>sem_init</code> returns 0.  On failure it returns -1 and sets
<var>errno</var> to one of the following values:

          <dl>
<dt><code>EINVAL</code><dd><var>value</var> exceeds the maximal counter value <code>SEM_VALUE_MAX</code>

          <br><dt><code>ENOSYS</code><dd><var>pshared</var> is not zero.  LinuxThreads currently does not support
process-shared semaphores.  (This will eventually change.) 
</dl>
        </p></blockquote></div>

<!-- semaphore.h -->
<!-- POSIX -->
<div class="defun">
&mdash; Function: int <b>sem_destroy</b> (<var>sem_t * sem</var>)<var><a name="index-sem_005fdestroy-3747"></a></var><br>
<blockquote><p><code>sem_destroy</code> destroys a semaphore object, freeing the resources it
might hold.  If any threads are waiting on the semaphore when
<code>sem_destroy</code> is called, it fails and sets <var>errno</var> to
<code>EBUSY</code>.

        <p>In the LinuxThreads implementation, no resources are associated with
semaphore objects, thus <code>sem_destroy</code> actually does nothing except
checking that no thread is waiting on the semaphore.  This will change
when process-shared semaphores are implemented. 
</p></blockquote></div>

<!-- semaphore.h -->
<!-- POSIX -->
<div class="defun">
&mdash; Function: int <b>sem_wait</b> (<var>sem_t * sem</var>)<var><a name="index-sem_005fwait-3748"></a></var><br>
<blockquote><p><code>sem_wait</code> suspends the calling thread until the semaphore pointed
to by <var>sem</var> has non-zero count. It then atomically decreases the
semaphore count.

        <p><code>sem_wait</code> is a cancellation point.  It always returns 0. 
</p></blockquote></div>

<!-- semaphore.h -->
<!-- POSIX -->
<div class="defun">
&mdash; Function: int <b>sem_trywait</b> (<var>sem_t * sem</var>)<var><a name="index-sem_005ftrywait-3749"></a></var><br>
<blockquote><p><code>sem_trywait</code> is a non-blocking variant of <code>sem_wait</code>. If the
semaphore pointed to by <var>sem</var> has non-zero count, the count is
atomically decreased and <code>sem_trywait</code> immediately returns 0.  If
the semaphore count is zero, <code>sem_trywait</code> immediately returns -1
and sets errno to <code>EAGAIN</code>. 
</p></blockquote></div>

<!-- semaphore.h -->
<!-- POSIX -->
<div class="defun">
&mdash; Function: int <b>sem_post</b> (<var>sem_t * sem</var>)<var><a name="index-sem_005fpost-3750"></a></var><br>
<blockquote><p><code>sem_post</code> atomically increases the count of the semaphore pointed to
by <var>sem</var>. This function never blocks.

     <!-- !!! This para appears not to agree with the code. -->
<p>On processors supporting atomic compare-and-swap (Intel 486, Pentium and
later, Alpha, PowerPC, MIPS II, Motorola 68k, Ultrasparc), the
<code>sem_post</code> function is can safely be called from signal handlers. 
This is the only thread synchronization function provided by POSIX
threads that is async-signal safe.  On the Intel 386 and earlier Sparc
chips, the current LinuxThreads implementation of <code>sem_post</code> is not
async-signal safe, because the hardware does not support the required
atomic operations.

        <p><code>sem_post</code> always succeeds and returns 0, unless the semaphore
count would exceed <code>SEM_VALUE_MAX</code> after being incremented.  In
that case <code>sem_post</code> returns -1 and sets <var>errno</var> to
<code>EINVAL</code>.  The semaphore count is left unchanged. 
</p></blockquote></div>

<!-- semaphore.h -->
<!-- POSIX -->
<div class="defun">
&mdash; Function: int <b>sem_getvalue</b> (<var>sem_t * sem, int * sval</var>)<var><a name="index-sem_005fgetvalue-3751"></a></var><br>
<blockquote><p><code>sem_getvalue</code> stores in the location pointed to by <var>sval</var> the
current count of the semaphore <var>sem</var>.  It always returns 0. 
</p></blockquote></div>

   </body></html>

