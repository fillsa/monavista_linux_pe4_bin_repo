
<!--
  t
   Copyright \(co 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1994, 1996 X Consortium
   
   Permission is hereby granted, free of charge, to any person obtaining
   a copy of this software and associated documentation files (the
   "Software"), to deal in the Software without restriction, including
   without limitation the rights to use, copy, modify, merge, publish,
   distribute, sublicense, and/or sell copies of the Software, and to
   permit persons to whom the Software is furnished to do so, subject to
   the following conditions:
   
   The above copyright notice and this permission notice shall be included
   in all copies or substantial portions of the Software.
   
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
   IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR
   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   OTHER DEALINGS IN THE SOFTWARE.
   
   Except as contained in this notice, the name of the X Consortium shall
   not be used in advertising or otherwise to promote the sale, use or
   other dealings in this Software without prior written authorization
   from the X Consortium.
   
   Copyright \(co 1985, 1986, 1987, 1988, 1989, 1990, 1991 by
   Digital Equipment Corporation
   
   Portions Copyright \(co 1990, 1991 by
   Tektronix, Inc.
   
   Permission to use, copy, modify and distribute this documentation for
   any purpose and without fee is hereby granted, provided that the above
   copyright notice appears in all copies and that both that copyright notice
   and this permission notice appear in all copies, and that the names of
   Digital and Tektronix not be used in in advertising or publicity pertaining
   to this documentation without specific, written prior permission.
   Digital and Tektronix makes no representations about the suitability
   of this documentation for any purpose.
   It is provided ``as is'' without express or implied warranty.
   
   $XFree86: xc/doc/man/X11/XCreGC.man,v 1.6 2003/04/28 22:17:54 herrb Exp $
   $XdotOrg: xc/doc/man/X11/XCreGC.man,v 1.2 2004/04/23 18:42:09 eich Exp $
   
 
-->

<!--
  Note End -- doug kraft 3/85
 
-->
 
<!--
  t
 
-->
<!-- manual page source format generated by PolyglotMan v3.0.8+X.Org, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>XCreateGC(3X11) manual page</title>
</head>
<body bgcolor='#efefef' text='black' link='blue' vlink='#551A8B' alink='red'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
XCreateGC, XCopyGC,
XChangeGC, XGetGCValues, XFreeGC, XGContextFromGC, XGCValues - create or
free graphics contexts and graphics context structure 
<h2><a name='sect1' href='#toc1'>Syntax</a></h2>

<dl>

<dt>GC XCreateGC(Display
*<i>display</i>, Drawable <i>d</i>, unsigned long </dt>
<dd><i>valuemask</i>, XGCValues *<i>values</i>);  </dd>

<dt>int
XCopyGC(Display *<i>display</i>, GC <i>src</i>, GC <i>dest</i>, </dt>
<dd>unsigned long <i>valuemask</i>);  </dd>

<dt>int
XChangeGC(Display *<i>display</i>, GC <i>gc</i>, unsigned long </dt>
<dd><i>valuemask</i>, XGCValues *<i>values</i>);
 </dd>

<dt>Status XGetGCValues(Display *<i>display</i>, GC <i>gc</i>, unsigned long </dt>
<dd><i>valuemask</i>,
XGCValues *<i>values_return</i>);  </dd>

<dt>int XFreeGC(Display *<i>display</i>, GC <i>gc</i>);  </dt>
<dd></dd>

<dt>GContext
XGContextFromGC(GC <i>gc</i>);  </dt>
<dd></dd>
</dl>

<h2><a name='sect2' href='#toc2'>Arguments</a></h2>

<dl>

<dt><i>d</i></dt>
<dd>Specifies the drawable.  </dd>

<dt><i>dest</i></dt>
<dd>Specifies
the destination GC. </dd>

<dt><i>display</i></dt>
<dd>Specifies the connection to the X server. </dd>

<dt><i>gc</i></dt>
<dd>Specifies
the GC. </dd>

<dt><i>src</i></dt>
<dd>Specifies the components of the source GC. </dd>

<dt><i>valuemask</i></dt>
<dd>Specifies
which components in the GC are to be <code>m.  This argument is the bitwise inclusive
OR of zero or more of the valid GC component mask bits. </dd>

<dt><i>values</i></code></dt>
<dd>Specifies
any values as specified by the valuemask. </dd>

<dt><i>values_return</i></dt>
<dd>Returns the GC values
in the specified <i>XGCValues</i>   structure. </dd>
</dl>

<h2><a name='sect3' href='#toc3'>Description</a></h2>
The <i>XCreateGC</i>   function
creates a graphics context and returns a GC. The GC can be used with any
destination drawable having the same root and depth as the specified drawable.
Use with other drawables results in a <i>BadMatch</i>   error. <p>
<i>XCreateGC</i>   can
generate <i>BadAlloc</i>,   <i>BadDrawable</i>,   <i>BadFont</i>,   <i>BadMatch</i>,   <i>BadPixmap</i>, 
 and <i>BadValue</i>   errors. <p>
The <i>XCopyGC</i>   function copies the specified components
from the source GC to the destination GC. The source and destination GCs
must have the same root and depth, or a <i>BadMatch</i>   error results. The valuemask
specifies which component to copy, as for <i>XCreateGC</i>.   <p>
<i>XCopyGC</i>   can generate
<i>BadAlloc</i>,   <i>BadGC</i>,   and <i>BadMatch</i>   errors. <p>
The <i>XChangeGC</i>   function changes
the components specified by valuemask for the specified GC. The values argument
contains the values to be set. The values and restrictions are the same
as for  <i>XCreateGC</i>.   Changing the clip-mask overrides any previous  <i>XSetClipRectangles</i>
  request on the context.  Changing the dash-offset or dash-list overrides
any previous  <i>XSetDashes</i>   request on the context. The order in which components
are verified and altered is server dependent. If an error is generated,
a subset of the components may have been altered. <p>
<i>XChangeGC</i>   can generate
<i>BadAlloc</i>,   <i>BadFont</i>,   <i>BadGC</i>,   <i>BadMatch</i>,   <i>BadPixmap</i>,   and <i>BadValue</i> 
 errors. <p>
The <i>XGetGCValues</i>   function returns the components specified by
valuemask for the specified GC. If the valuemask contains a valid set of
GC mask bits (<i>GCFunction</i>,   <i>GCPlaneMask</i>,   <i>GCForeground</i>,   <i>GCBackground</i>,
  <i>GCLineWidth</i>,   <i>GCLineStyle</i>,   <i>GCCapStyle</i>,   <i>GCJoinStyle</i>,   <i>GCFillStyle</i>,
  <i>GCFillRule</i>,   <i>GCTile</i>,   <i>GCStipple</i>,   <i>GCTileStipXOrigin</i>,   <i>GCTileStipYOrigin</i>,
  <i>GCFont</i>,   <i>GCSubwindowMode</i>,   <i>GCGraphicsExposures</i>,   <i>GCClipXOrigin</i>,  
<i>GCCLipYOrigin</i>,   <i>GCDashOffset</i>,   or <i>GCArcMode</i>)   and no error occurs, <i>XGetGCValues</i>
  sets the requested components in values_return and returns a nonzero
status. Otherwise, it returns a zero status. Note that the clip-mask and dash-list
(represented by the <i>GCClipMask</i>   and  <i>GCDashList</i>   bits, respectively,
in the valuemask) cannot be requested. Also note that an invalid resource
ID (with one or more of the three most significant bits set to 1) will
be returned for <i>GCFont</i>,   <i>GCTile</i>,   and <i>GCStipple</i>   if the component has
never been explicitly set by the client. <p>
The <i>XFreeGC</i>   function destroys
the specified GC as well as all the associated storage. <p>
<i>XFreeGC</i>   can generate
a <i>BadGC</i>   error. 
<h2><a name='sect4' href='#toc4'>Structures</a></h2>
The <i>XGCValues</i>   structure contains: <p>
<p>
/* GC attribute
value mask bits */ <table border='0'>
<tr><td align='left'>#define</td></tr>
<i>GCFunction</i>   <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;0)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define </td></tr>
<i>GCPlaneMask</i> 
 <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;1)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define </td></tr>
<i>GCForeground</i>   <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;2)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define </td></tr>
<i>GCBackground</i>   <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;3)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define
</td></tr>
<i>GCLineWidth</i>   <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;4)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define </td></tr>
<i>GCLineStyle</i>   <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;5)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define </td></tr>
<i>GCCapStyle</i>
  <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;6)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define </td></tr>
<i>GCJoinStyle</i>   <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;7)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define </td></tr>
<i>GCFillStyle</i>   <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;8)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define
</td></tr>
<i>GCFillRule</i>   <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;9)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define </td></tr>
<i>GCTile</i>   <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;10)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define </td></tr>
<i>GCStipple</i>
  <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;11)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define </td></tr>
<i>GCTileStipXOrigin</i>   <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;12)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define </td></tr>
<i>GCTileStipYOrigin</i>
  <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;13)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define </td></tr>
<i>GCFont</i>   <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;14)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define </td></tr>
<i>GCSubwindowMode</i>   <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;15)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define
</td></tr>
<i>GCGraphicsExposures</i>   <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;16)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define </td></tr>
<i>GCClipXOrigin</i>   <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;17)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define
</td></tr>
<i>GCClipYOrigin</i>   <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;18)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define </td></tr>
<i>GCClipMask</i>   <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;19)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define </td></tr>
<i>GCDashOffset</i>
  <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;20)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define </td></tr>
<i>GCDashList</i>   <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;21)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'>#define </td></tr>
<i>GCArcMode</i>   <tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(1L&lt;&lt;22)</td></tr>
<tr><td align='left'>T}</td></tr>
</table>

 <br>
<pre>0
0>=40 .vs 0u
0<=39 .vs 0p
/* Values */
typedef struct {
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;int function;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* logical operation */
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;unsigned long plane_mask;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* plane mask */
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;unsigned long foreground;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* foreground pixel */
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;unsigned long background;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* background pixel */
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;int line_width;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* line width (in pixels) */
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;int line_style;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* LineSolid, LineOnOffDash, LineDoubleDash */
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;int cap_style;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* CapNotLast, CapButt, CapRound, CapProjecting */
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;int join_style;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* JoinMiter, JoinRound, JoinBevel */
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;int fill_style;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* FillSolid, FillTiled, FillStippled FillOpaqueStippled*/
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;int fill_rule;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* EvenOddRule, WindingRule */
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;int arc_mode;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* ArcChord, ArcPieSlice */
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;Pixmap tile;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* tile pixmap for tiling operations */
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;Pixmap stipple;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* stipple 1 plane pixmap for stippling */
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;int ts_x_origin;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* offset for tile or stipple operations */
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;int ts_y_origin;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;Font font;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* default text font for text operations */
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;int subwindow_mode;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* ClipByChildren, IncludeInferiors */
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;Bool graphics_exposures;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* boolean, should exposures be generated */
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;int clip_x_origin;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* origin for clipping */
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;int clip_y_origin;
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;Pixmap clip_mask;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* bitmap clipping; other calls for rects */
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;int dash_offset;<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;/* patterned/dashed line information */
<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;char dashes;
} XGCValues;

</pre> <p>
The function attributes of a GC are used when you update a section of
a drawable (the destination) with bits from somewhere else (the source).
  The function in a GC defines how the new destination bits are to be computed
from the source bits and the old destination bits. <i>GXcopy</i>   is typically
the most useful because it will work on a color display, but special applications
may use other functions, particularly in concert with particular planes
of a color display. The 16 GC functions, defined in  &lt;<i>X11/X.h</i>&gt;,   are: 
<!--
  are listed in Table 5-1 along with the 
   associated hexadecimal code
   and operation.
   T 1

  Functions
 
-->
<table border='0'>
<tr> <p>
<b></b> <tr><td align='left'>Function Name<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;Value<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;Operation</td></tr>
<p>
<tr> <p>
<tr><td align='left'><i>GXclear</i>   </td></tr>
<tr><td align='left'>0x0</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>0</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'><i>GXand</i>   </td></tr>
<tr><td align='left'>0x1</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>src AND
dst</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'><i>GXandReverse</i>   </td></tr>
<tr><td align='left'>0x2</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>src AND NOT dst</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'><i>GXcopy</i>   </td></tr>
<tr><td align='left'>0x3</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>src</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'><i>GXandInverted</i>
  </td></tr>
<tr><td align='left'>0x4</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(NOT src) AND dst</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'><i>GXnoop</i>   </td></tr>
<tr><td align='left'>0x5</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>dst</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'><i>GXxor</i>   </td></tr>
<tr><td align='left'>0x6</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>src XOR
dst</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'><i>GXor</i>   </td></tr>
<tr><td align='left'>0x7</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>src OR dst</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'><i>GXnor</i>   </td></tr>
<tr><td align='left'>0x8</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(NOT src) AND (NOT dst)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'><i>GXequiv</i>
  </td></tr>
<tr><td align='left'>0x9</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(NOT src) XOR dst</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'><i>GXinvert</i>   </td></tr>
<tr><td align='left'>0xa</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>NOT dst</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'><i>GXorReverse</i>   </td></tr>
<tr><td align='left'>0xb</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>src
OR (NOT dst)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'><i>GXcopyInverted</i>   </td></tr>
<tr><td align='left'>0xc</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>NOT src</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'><i>GXorInverted</i>   </td></tr>
<tr><td align='left'>0xd</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(NOT
src) OR dst</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'><i>GXnand</i>   </td></tr>
<tr><td align='left'>0xe</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>(NOT src) OR (NOT dst)</td></tr>
<tr><td align='left'>T}</td></tr>
<tr><td align='left'><i>GXset</i>   </td></tr>
<tr><td align='left'>0xf</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>1</td></tr>
<tr><td align='left'>T}</td></tr>
<p>
<tr>
</table>
 <p>
Many graphics operations depend on either pixel values or planes in a
GC.  The planes attribute is of type long, and it specifies which planes
of the destination are to be modified, one bit per plane.  A monochrome
display has only one plane and will be the least significant bit of the
word. As planes are added to the display hardware, they will occupy more
significant bits in the plane mask. <p>
In graphics operations, given a source
and destination pixel,  the result is computed bitwise on corresponding
bits of the pixels. That is, a Boolean operation is performed in each bit
plane.   The plane_mask restricts the operation to a subset of planes. A
macro constant <i>AllPlanes</i>   can be used to refer to all planes of the screen
simultaneously. The result is computed by the following: <p>
<br>
<pre>0
0>=40 .vs 0u
0<=39 .vs 0p
((src FUNC dst) AND plane-mask) OR (dst AND (NOT plane-mask))

</pre> <p>
Range checking is not performed on the values for foreground, background,
or plane_mask. They are simply truncated to the appropriate number of bits.
The line-width is measured in pixels and either can be greater than or equal
to one (wide line) or can be the special value zero (thin line). <p>
Wide lines
are drawn centered on the path described by the graphics request. Unless
otherwise specified by the join-style or cap-style, the bounding box of a
wide line with endpoints [x1, y1], [x2, y2] and width w is a rectangle
with vertices at the following real coordinates: <p>
<br>
<pre>0
0>=40 .vs 0u
0<=39 .vs 0p
[x1-(w*sn/2), y1+(w*cs/2)], [x1+(w*sn/2), y1-(w*cs/2)],
[x2-(w*sn/2), y2+(w*cs/2)], [x2+(w*sn/2), y2-(w*cs/2)]

</pre> <p>
Here sn is the sine of the angle of the line, and cs is the cosine of
the angle of the line. A pixel is part of the line and so is drawn if the
center of the pixel is fully inside the bounding box (which is viewed as
having infinitely thin edges). If the center of the pixel is exactly on
the bounding box, it is part of the line if and only if the interior is
immediately to its right (x increasing direction). Pixels with centers on
a horizontal edge are a special case and are part of the line if and only
if the interior or the boundary is immediately below  (y increasing direction)
and the interior or the boundary is immediately to the right (x increasing
direction). <p>
Thin lines (zero line-width) are one-pixel-wide lines drawn using
an unspecified, device-dependent algorithm. There are only two constraints
on this algorithm.  
<dl>

<dt>1.</dt>
<dd>If a line is drawn unclipped from [x1,y1] to [x2,y2]
and if another line is drawn unclipped from [x1+dx,y1+dy] to [x2+dx,y2+dy],
a point [x,y] is touched by drawing the first line  if and only if the
point [x+dx,y+dy] is touched by drawing the second line. </dd>

<dt>2.</dt>
<dd>The effective
set of points comprising a line cannot be affected by clipping. That is,
a point is touched in a clipped line if and only if the point  lies inside
the clipping region and the point would be touched by the line when drawn
unclipped. </dd>
</dl>
<p>
A wide line drawn from [x1,y1] to [x2,y2] always draws the same
pixels  as a wide line drawn from [x2,y2] to [x1,y1], not counting cap-style
 and join-style. It is recommended that this property be true for thin lines,
 but this is not required. A line-width of zero may differ from a line-width
of one in which pixels are drawn. This permits the use of many manufacturers'
line drawing hardware, which may run many times faster than the more precisely
specified wide lines. <p>
In general,  drawing a thin line will be faster than
drawing a wide line of width one. However, because of their different drawing
algorithms, thin lines may not mix well aesthetically with wide lines. If
it is desirable to obtain precise and uniform results across all displays,
a client should always use a line-width of one rather than a line-width of
zero. <p>
The line-style defines which sections of a line are drawn: <table border='0'>
<tr><td align='left'><i>LineSolid</i>
  </td></tr>
<tr><td align='left'>The full path of the line is drawn.</td></tr>
<tr><td align='left'>T}</td></tr>
<p>
<tr><td align='left'><i>LineDoubleDash</i>   </td></tr>
<tr><td align='left'>The full path of
the line is drawn, </td></tr>
<tr><td align='left'>but the even dashes are filled differently </td></tr>
<tr><td align='left'>from the
odd dashes (see fill-style) with</td></tr>
<i>CapButt</i>   <tr><td align='left'>style used where even and odd
dashes meet.</td></tr>
<tr><td align='left'>T}</td></tr>
<p>
<tr><td align='left'><i>LineOnOffDash</i>   </td></tr>
<tr><td align='left'>Only the even dashes are drawn,</td></tr>
<tr><td align='left'>and cap-style
applies to </td></tr>
<tr><td align='left'>all internal ends of the individual dashes,</td></tr>
<tr><td align='left'>except </td></tr>
<i>CapNotLast</i>
  <tr><td align='left'>is treated as </td></tr>
<i>CapButt</i>.   <tr><td align='left'>T}</td></tr>
</table>
 <p>
The cap-style defines how the endpoints of
a path are drawn:  <table border='0'>
<tr><td align='left'><i>CapNotLast</i>   </td></tr>
<tr><td align='left'>This is equivalent to </td></tr>
<i>CapButt</i>   <tr><td align='left'>except
that for a line-width of zero the final endpoint is not drawn.</td></tr>
<tr><td align='left'>T}</td></tr>
<p>
<tr><td align='left'><i>CapButt</i> 
 </td></tr>
<tr><td align='left'>The line is square at the endpoint (perpendicular to the slope of the
line)</td></tr>
<tr><td align='left'>with no projection beyond.</td></tr>
<tr><td align='left'>T}</td></tr>
<p>
<tr><td align='left'><i>CapRound</i>   </td></tr>
<tr><td align='left'>The line has a circular arc
with the diameter equal to the line-width,</td></tr>
<tr><td align='left'>centered on the endpoint.</td></tr>
<tr><td align='left'>(This
is equivalent to </td></tr>
<i>CapButt</i>   <tr><td align='left'>for line-width of zero).</td></tr>
<tr><td align='left'>T}</td></tr>
<p>
<tr><td align='left'><i>CapProjecting</i>   </td></tr>
<tr><td align='left'>The
line is square at the end, but the path continues beyond the endpoint </td></tr>
<tr><td align='left'>for
a distance equal to half the line-width.</td></tr>
<tr><td align='left'>(This is equivalent to </td></tr>
<i>CapButt</i>  
<tr><td align='left'>for line-width of zero).</td></tr>
<tr><td align='left'>T}</td></tr>
</table>
 <p>
The join-style defines how corners are drawn for
wide lines: <table border='0'>
<tr><td align='left'><i>JoinMiter</i>   </td></tr>
<tr><td align='left'>The outer edges of two lines extend to meet at
an angle.</td></tr>
<tr><td align='left'>However, if the angle is less than 11 degrees,</td></tr>
<tr><td align='left'>then a</td></tr>
<i>JoinBevel</i> 
 <tr><td align='left'>join-style is used instead.</td></tr>
<tr><td align='left'>T}</td></tr>
<p>
<tr><td align='left'><i>JoinRound</i>   </td></tr>
<tr><td align='left'>The corner is a circular arc with
the diameter equal to the line-width, </td></tr>
<tr><td align='left'>centered on the joinpoint.</td></tr>
<tr><td align='left'>T}</td></tr>
<p>
<tr><td align='left'><i>JoinBevel</i>
  </td></tr>
<tr><td align='left'>The corner has</td></tr>
<i>CapButt</i>   <tr><td align='left'>endpoint styles with the triangular notch filled.</td></tr>
<tr><td align='left'>T}</td></tr>
</table>

<p>
For a line with coincident endpoints (x1=x2, y1=y2),  when the cap-style
is applied to both endpoints,  the semantics depends on the line-width and
the cap-style: <table border='0'>
<tr><td align='left'><i>CapNotLast</i>   </td></tr>
<tr><td align='left'>thin</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>The results are device dependent, </td></tr>
<tr><td align='left'>but
the desired effect is that nothing is drawn.</td></tr>
<tr><td align='left'>T}</td></tr>
<p>
<tr><td align='left'><i>CapButt</i>   </td></tr>
<tr><td align='left'>thin</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>The results
are device dependent, </td></tr>
<tr><td align='left'>but the desired effect is that a single pixel is
drawn.</td></tr>
<tr><td align='left'>T}</td></tr>
<p>
<tr><td align='left'><i>CapRound</i>   </td></tr>
<tr><td align='left'>thin</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>The results are the same as for</td></tr>
<i>CapButt</i>/thin. 
 <tr><td align='left'>T}</td></tr>
<p>
<tr><td align='left'><i>CapProjecting</i>   </td></tr>
<tr><td align='left'>thin</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>The results are the same as for</td></tr>
<i>CapButt</i>/thin.
  <tr><td align='left'>T}</td></tr>
<p>
<tr><td align='left'><i>CapButt</i>   </td></tr>
<tr><td align='left'>wide</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>Nothing is drawn.</td></tr>
<tr><td align='left'>T}</td></tr>
<p>
<tr><td align='left'><i>CapRound</i>   </td></tr>
<tr><td align='left'>wide</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>The closed path
is a circle, centered at the endpoint, and</td></tr>
<tr><td align='left'>with the diameter equal to the
line-width.</td></tr>
<tr><td align='left'>T}</td></tr>
<p>
<tr><td align='left'><i>CapProjecting</i>   </td></tr>
<tr><td align='left'>wide</td></tr>
<tr><td align='left'>T}<tt>&#32;</tt>&nbsp;<tt>&#32;</tt>&nbsp;T{</td></tr>
<tr><td align='left'>The closed path is a square, aligned
with the coordinate axes, centered at the</td></tr>
<tr><td align='left'>endpoint, and with the sides equal
to the line-width.</td></tr>
<tr><td align='left'>T}</td></tr>
</table>
 <p>
For a line with coincident endpoints (x1=x2, y1=y2),
 when the join-style is applied at one or both endpoints,  the effect is
as if the line was removed from the overall path. However, if the total
path consists of or is reduced to a single point joined with itself, the
effect is the same as when the cap-style is applied at both endpoints. <p>
The
tile/stipple represents an infinite two-dimensional plane, with the tile/stipple
replicated in all dimensions. When that plane is superimposed on the drawable
for use in a graphics operation, the upper-left corner of some instance
of the tile/stipple is at the coordinates within the drawable specified
by the tile/stipple origin. The tile/stipple and clip origins are interpreted
relative to the origin of whatever destination drawable is specified in
a graphics request. The tile pixmap must have the same root and depth as
the GC, or a <i>BadMatch</i>   error results. The stipple pixmap must have depth
one and must have the same root as the GC, or a  <i>BadMatch</i>   error results.
  For stipple operations where the fill-style is <i>FillStippled</i>   but not
 <i>FillOpaqueStippled</i>,   the stipple pattern is tiled in a single plane and
acts as an additional clip mask to be ANDed with the clip-mask. Although
some sizes may be faster to use than others, any size pixmap can be used
for tiling or stippling. <p>
The fill-style defines the contents of the source
for line, text, and fill requests.   For all text and fill requests (for
example, <i>XDrawText</i>,   <i>XDrawText16</i>,   <i>XFillRectangle</i>,   <i>XFillPolygon</i>,  
and <i>XFillArc</i>);   for line requests  with line-style  <i>LineSolid</i>   (for example,
<i>XDrawLine</i>,   <i>XDrawSegments</i>,   <i>XDrawRectangle</i>,   <i>XDrawArc</i>);   and for the
even dashes for line requests with line-style  <i>LineOnOffDash</i>   or  <i>LineDoubleDash</i>,
  the following apply: <table border='0'>
<tr><td align='left'><i>FillSolid</i>   </td></tr>
<tr><td align='left'>Foreground</td></tr>
<tr><td align='left'>T}</td></tr>
<p>
<tr><td align='left'><i>FillTiled</i>   </td></tr>
<tr><td align='left'>Tile</td></tr>
<tr><td align='left'>T}</td></tr>
<p>
<tr><td align='left'><i>FillOpaqueStippled</i>
  </td></tr>
<tr><td align='left'>A tile with the same width and height as stipple,</td></tr>
<tr><td align='left'>but with background
everywhere stipple has a zero</td></tr>
<tr><td align='left'>and with foreground everywhere stipple has
a one</td></tr>
<tr><td align='left'>T}</td></tr>
<p>
<tr><td align='left'><i>FillStippled</i>   </td></tr>
<tr><td align='left'>Foreground masked by stipple</td></tr>
<tr><td align='left'>T}</td></tr>
</table>
 <p>
When drawing lines
with line-style <i>LineDoubleDash</i>,   the odd dashes are controlled by the fill-style
in the following manner: <table border='0'>
<tr><td align='left'><i>FillSolid</i>   </td></tr>
<tr><td align='left'>Background</td></tr>
<tr><td align='left'>T}</td></tr>
<p>
<tr><td align='left'><i>FillTiled</i>   </td></tr>
<tr><td align='left'>Same as for
even dashes</td></tr>
<tr><td align='left'>T}</td></tr>
<p>
<tr><td align='left'><i>FillOpaqueStippled</i>   </td></tr>
<tr><td align='left'>Same as for even dashes</td></tr>
<tr><td align='left'>T}</td></tr>
<p>
<tr><td align='left'><i>FillStippled</i>
  </td></tr>
<tr><td align='left'>Background masked by stipple</td></tr>
<tr><td align='left'>T}</td></tr>
</table>
 <p>
Storing a pixmap in a GC might or might
not result in a copy being made. If the pixmap is later used as the destination
for a graphics request, the change might or might not be reflected in the
GC. If the pixmap is used simultaneously in a graphics request both as a
destination and as a tile or stipple, the results are undefined. <p>
For optimum
performance, you should draw as much as possible with the same GC  (without
changing its components). The costs of changing GC components relative to
using different GCs depend on the display hardware and the server implementation.
It is quite likely that some amount of GC information will be cached in
display hardware and that such hardware can only cache a small number of
GCs. <p>
The dashes value is actually a simplified form of the more general
patterns that can be set with  <i>XSetDashes</i>.   Specifying a value of N is
equivalent to specifying the two-element list [N, N] in  <i>XSetDashes</i>.   The
value must be nonzero, or a <i>BadValue</i>   error results. <p>
The clip-mask restricts
writes to the destination drawable.   If the clip-mask is set to a pixmap,
it must have depth one and have the same root as the GC, or a <i>BadMatch</i>
  error results. If clip-mask is set to <i>None</i>,   the pixels are always drawn
regardless of the clip origin. The clip-mask also can be set by calling the
<i>XSetClipRectangles</i>   or <i>XSetRegion</i>   functions. Only pixels where the clip-mask
has a bit set to 1 are drawn.   Pixels are not drawn outside the area covered
by the clip-mask  or where the clip-mask has a bit set to 0. The clip-mask
affects all graphics requests. The clip-mask does not clip sources. The clip-mask
origin is interpreted relative to the origin of whatever destination drawable
is specified in a graphics request. <p>
You can set the subwindow-mode to <i>ClipByChildren</i>
  or <i>IncludeInferiors</i>.   For  <i>ClipByChildren</i>,   both source and destination
windows are additionally clipped by all viewable  <i>InputOutput</i>   children.
  For  <i>IncludeInferiors</i>,   neither source nor destination window is clipped
by inferiors.  This will result in including subwindow contents in the source
and drawing through subwindow boundaries of the destination. The use of
 <i>IncludeInferiors</i>   on a window of one depth with mapped inferiors of differing
depth is not illegal, but the semantics are undefined by the core protocol.
<p>
The fill-rule defines what pixels are inside (drawn) for paths given in
 <i>XFillPolygon</i>   requests and can be set to  <i>EvenOddRule</i>   or <i>WindingRule</i>.
  For <i>EvenOddRule</i>,   a point is inside if an infinite ray with the point
as origin crosses the path an odd number of times.   For  <i>WindingRule</i>, 
 a point is inside if an infinite ray with the point as origin crosses
an unequal number of clockwise and counterclockwise directed path segments.
A clockwise directed path segment is one that crosses the ray from left
to right as observed from the point. A counterclockwise segment is one that
crosses the ray from right to left as observed from the point. The case
where a directed line segment is coincident with the ray is uninteresting
because you can simply choose a different ray that is not coincident with
a segment. <p>
For both  <i>EvenOddRule</i>   and <i>WindingRule</i>,   a point is infinitely
small,  and the path is an infinitely thin line.   A pixel is inside if
the center point of the pixel is inside and the center point is not on
the boundary.   If the center point is on the boundary, the pixel is inside
if and only if the polygon interior is immediately to its right (x increasing
direction).   Pixels with centers on a horizontal edge are a special case
 and are inside if and only if the polygon interior is immediately below
 (y increasing direction). <p>
The arc-mode controls filling in the  <i>XFillArcs</i>
  function and can be set to <i>ArcPieSlice</i>   or <i>ArcChord</i>.   For <i>ArcPieSlice</i>,
  the arcs are pie-slice filled. For <i>ArcChord</i>,   the arcs are chord filled.
<p>
The graphics-exposure flag controls  <i>GraphicsExpose</i>   event generation for
 <i>XCopyArea</i>   and  <i>XCopyPlane</i>   requests (and any similar requests defined
by extensions). 
<h2><a name='sect5' href='#toc5'>Diagnostics</a></h2>

<dl>

<dt><i>BadAlloc</i> </dt>
<dd>  The server failed to allocate the
requested resource or server memory. </dd>

<dt><i>BadDrawable</i> </dt>
<dd>  A value for a Drawable
argument does not name a defined Window or Pixmap. </dd>

<dt><i>BadFont</i> </dt>
<dd>  A value for
a Font or GContext argument does not name a defined Font. </dd>

<dt><i>BadGC</i> </dt>
<dd>  A value
for a GContext argument does not name a defined GContext. </dd>

<dt><i>BadMatch</i> </dt>
<dd>  An
<i>InputOnly</i>   window is used as a Drawable. </dd>

<dt><i>BadMatch</i> </dt>
<dd>  Some argument or pair
of arguments has the correct type and range but fails to match in some
other way required by the request. </dd>

<dt><i>BadPixmap</i> </dt>
<dd>  A value for a Pixmap argument
does not name a defined Pixmap. </dd>

<dt><i>BadValue</i> </dt>
<dd>  Some numeric value falls outside
the range of values accepted by the request. Unless a specific range is
specified for an argument, the full range defined by the argument's type
is accepted.  Any argument defined as a set of alternatives can generate
this error. </dd>
</dl>

<h2><a name='sect6' href='#toc6'>See Also</a></h2>
<a href='AllPlanes.3.html'>AllPlanes(3X11)</a>
, <a href='XCopyArea.3.html'>XCopyArea(3X11)</a>
, <a href='XCreateRegion.3.html'>XCreateRegion(3X11)</a>
,
<a href='XDrawArc.3.html'>XDrawArc(3X11)</a>
, <a href='XDrawLine.3.html'>XDrawLine(3X11)</a>
, <a href='XDrawRectangle.3.html'>XDrawRectangle(3X11)</a>
, <a href='XDrawText.3.html'>XDrawText(3X11)</a>
,
<a href='XFillRectangle.3.html'>XFillRectangle(3X11)</a>
, <a href='XQueryBestSize.3.html'>XQueryBestSize(3X11)</a>
, <a href='XSetArcMode.3.html'>XSetArcMode(3X11)</a>
, <a href='XSetClipOrigin.3.html'>XSetClipOrigin(3X11)</a>
,
<a href='XSetFillStyle.3.html'>XSetFillStyle(3X11)</a>
, <a href='XSetFont.3.html'>XSetFont(3X11)</a>
, <a href='XSetLineAttributes.3.html'>XSetLineAttributes(3X11)</a>
, <a href='XSetState.3.html'>XSetState(3X11)</a>
,
<a href='XSetTile.3.html'>XSetTile(3X11)</a>
 <br>
<i>Xlib - C Language X Interface</i> <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Syntax</a></li>
<li><a name='toc2' href='#sect2'>Arguments</a></li>
<li><a name='toc3' href='#sect3'>Description</a></li>
<li><a name='toc4' href='#sect4'>Structures</a></li>
<li><a name='toc5' href='#sect5'>Diagnostics</a></li>
<li><a name='toc6' href='#sect6'>See Also</a></li>
</ul>
</body>
</html>
