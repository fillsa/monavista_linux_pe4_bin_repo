<html lang="en">
<head>
<title>Mutexes - The GNU C Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The GNU C Library">
<meta name="generator" content="makeinfo 4.7">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="POSIX-Threads.html#POSIX-Threads" title="POSIX Threads">
<link rel="prev" href="Cleanup-Handlers.html#Cleanup-Handlers" title="Cleanup Handlers">
<link rel="next" href="Condition-Variables.html#Condition-Variables" title="Condition Variables">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc { font-variant:small-caps }
  span.roman { font-family: serif; font-weight: normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Mutexes"></a>Next:&nbsp;<a rel="next" accesskey="n" href="Condition-Variables.html#Condition-Variables">Condition Variables</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Cleanup-Handlers.html#Cleanup-Handlers">Cleanup Handlers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="POSIX-Threads.html#POSIX-Threads">POSIX Threads</a>
<hr><br>
</div>

<h3 class="section">34.5 Mutexes</h3>

<p>A mutex is a MUTual EXclusion device, and is useful for protecting
shared data structures from concurrent modifications, and implementing
critical sections and monitors.

   <p>A mutex has two possible states: unlocked (not owned by any thread),
and locked (owned by one thread). A mutex can never be owned by two
different threads simultaneously. A thread attempting to lock a mutex
that is already locked by another thread is suspended until the owning
thread unlocks the mutex first.

   <p>None of the mutex functions is a cancellation point, not even
<code>pthread_mutex_lock</code>, in spite of the fact that it can suspend a
thread for arbitrary durations. This way, the status of mutexes at
cancellation points is predictable, allowing cancellation handlers to
unlock precisely those mutexes that need to be unlocked before the
thread stops executing. Consequently, threads using deferred
cancellation should never hold a mutex for extended periods of time.

   <p>It is not safe to call mutex functions from a signal handler.  In
particular, calling <code>pthread_mutex_lock</code> or
<code>pthread_mutex_unlock</code> from a signal handler may deadlock the
calling thread.

<!-- pthread.h -->
<!-- POSIX -->
<div class="defun">
&mdash; Function: int <b>pthread_mutex_init</b> (<var>pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr</var>)<var><a name="index-pthread_005fmutex_005finit-3727"></a></var><br>
<blockquote>
<p><code>pthread_mutex_init</code> initializes the mutex object pointed to by
<var>mutex</var> according to the mutex attributes specified in <var>mutexattr</var>. 
If <var>mutexattr</var> is <code>NULL</code>, default attributes are used instead.

        <p>The LinuxThreads implementation supports only one mutex attribute,
the <var>mutex type</var>, which is either &ldquo;fast&rdquo;, &ldquo;recursive&rdquo;, or
&ldquo;error checking&rdquo;. The type of a mutex determines whether
it can be locked again by a thread that already owns it. 
The default type is &ldquo;fast&rdquo;.

        <p>Variables of type <code>pthread_mutex_t</code> can also be initialized
statically, using the constants <code>PTHREAD_MUTEX_INITIALIZER</code> (for
timed mutexes), <code>PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP</code> (for
recursive mutexes), <code>PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP</code>
(for fast mutexes(, and <code>PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP</code>
(for error checking mutexes).

        <p><code>pthread_mutex_init</code> always returns 0. 
</p></blockquote></div>

<!-- pthread.h -->
<!-- POSIX -->
<div class="defun">
&mdash; Function: int <b>pthread_mutex_lock</b> (<var>pthread_mutex_t *mutex</var>))<var><a name="index-pthread_005fmutex_005flock-3728"></a></var><br>
<blockquote><p><code>pthread_mutex_lock</code> locks the given mutex. If the mutex is
currently unlocked, it becomes locked and owned by the calling thread,
and <code>pthread_mutex_lock</code> returns immediately. If the mutex is
already locked by another thread, <code>pthread_mutex_lock</code> suspends the
calling thread until the mutex is unlocked.

        <p>If the mutex is already locked by the calling thread, the behavior of
<code>pthread_mutex_lock</code> depends on the type of the mutex. If the mutex
is of the &ldquo;fast&rdquo; type, the calling thread is suspended.  It will
remain suspended forever, because no other thread can unlock the mutex. 
If  the mutex is of the &ldquo;error checking&rdquo; type, <code>pthread_mutex_lock</code>
returns immediately with the error code <code>EDEADLK</code>.  If the mutex is
of the &ldquo;recursive&rdquo; type, <code>pthread_mutex_lock</code> succeeds and
returns immediately, recording the number of times the calling thread
has locked the mutex. An equal number of <code>pthread_mutex_unlock</code>
operations must be performed before the mutex returns to the unlocked
state. 
<!-- This doesn't discuss PTHREAD_MUTEX_TIMED_NP mutex attributes. FIXME -->
</p></blockquote></div>

<!-- pthread.h -->
<!-- POSIX -->
<div class="defun">
&mdash; Function: int <b>pthread_mutex_trylock</b> (<var>pthread_mutex_t *mutex</var>)<var><a name="index-pthread_005fmutex_005ftrylock-3729"></a></var><br>
<blockquote><p><code>pthread_mutex_trylock</code> behaves identically to
<code>pthread_mutex_lock</code>, except that it does not block the calling
thread if the mutex is already locked by another thread (or by the
calling thread in the case of a &ldquo;fast&rdquo; mutex). Instead,
<code>pthread_mutex_trylock</code> returns immediately with the error code
<code>EBUSY</code>. 
</p></blockquote></div>

<!-- pthread.h -->
<!-- POSIX -->
<div class="defun">
&mdash; Function: int <b>pthread_mutex_timedlock</b> (<var>pthread_mutex_t *mutex, const struct timespec *abstime</var>)<var><a name="index-pthread_005fmutex_005ftimedlock-3730"></a></var><br>
<blockquote><p>The <code>pthread_mutex_timedlock</code> is similar to the
<code>pthread_mutex_lock</code> function but instead of blocking for in
indefinite time if the mutex is locked by another thread, it returns
when the time specified in <var>abstime</var> is reached.

        <p>This function can only be used on standard (&ldquo;timed&rdquo;) and &ldquo;error
checking&rdquo; mutexes.  It behaves just like <code>pthread_mutex_lock</code> for
all other types.

        <p>If the mutex is successfully locked, the function returns zero.  If the
time specified in <var>abstime</var> is reached without the mutex being locked,
<code>ETIMEDOUT</code> is returned.

        <p>This function was introduced in the POSIX.1d revision of the POSIX standard. 
</p></blockquote></div>

<!-- pthread.h -->
<!-- POSIX -->
<div class="defun">
&mdash; Function: int <b>pthread_mutex_unlock</b> (<var>pthread_mutex_t *mutex</var>)<var><a name="index-pthread_005fmutex_005funlock-3731"></a></var><br>
<blockquote><p><code>pthread_mutex_unlock</code> unlocks the given mutex. The mutex is
assumed to be locked and owned by the calling thread on entrance to
<code>pthread_mutex_unlock</code>. If the mutex is of the &ldquo;fast&rdquo; type,
<code>pthread_mutex_unlock</code> always returns it to the unlocked state. If
it is of the &ldquo;recursive&rdquo; type, it decrements the locking count of the
mutex (number of <code>pthread_mutex_lock</code> operations performed on it by
the calling thread), and only when this count reaches zero is the mutex
actually unlocked.

        <p>On &ldquo;error checking&rdquo; mutexes, <code>pthread_mutex_unlock</code> actually
checks at run-time that the mutex is locked on entrance, and that it was
locked by the same thread that is now calling
<code>pthread_mutex_unlock</code>.  If these conditions are not met,
<code>pthread_mutex_unlock</code> returns <code>EPERM</code>, and the mutex remains
unchanged.  &ldquo;Fast&rdquo; and &ldquo;recursive&rdquo; mutexes perform no such checks,
thus allowing a locked mutex to be unlocked by a thread other than its
owner. This is non-portable behavior and must not be relied upon. 
</p></blockquote></div>

<!-- pthread.h -->
<!-- POSIX -->
<div class="defun">
&mdash; Function: int <b>pthread_mutex_destroy</b> (<var>pthread_mutex_t *mutex</var>)<var><a name="index-pthread_005fmutex_005fdestroy-3732"></a></var><br>
<blockquote><p><code>pthread_mutex_destroy</code> destroys a mutex object, freeing the
resources it might hold. The mutex must be unlocked on entrance. In the
LinuxThreads implementation, no resources are associated with mutex
objects, thus <code>pthread_mutex_destroy</code> actually does nothing except
checking that the mutex is unlocked.

        <p>If the mutex is locked by some thread, <code>pthread_mutex_destroy</code>
returns <code>EBUSY</code>.  Otherwise it returns 0. 
</p></blockquote></div>

   <p>If any of the above functions (except <code>pthread_mutex_init</code>)
is applied to an uninitialized mutex, they will simply return
<code>EINVAL</code> and do nothing.

   <p>A shared global variable <var>x</var> can be protected by a mutex as follows:

<pre class="smallexample">     int x;
     pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;
</pre>
   <p>All accesses and modifications to <var>x</var> should be bracketed by calls to
<code>pthread_mutex_lock</code> and <code>pthread_mutex_unlock</code> as follows:

<pre class="smallexample">     pthread_mutex_lock(&amp;mut);
     /* operate on x */
     pthread_mutex_unlock(&amp;mut);
</pre>
   <p>Mutex attributes can be specified at mutex creation time, by passing a
mutex attribute object as second argument to <code>pthread_mutex_init</code>. 
Passing <code>NULL</code> is equivalent to passing a mutex attribute object
with all attributes set to their default values.

<!-- pthread.h -->
<!-- POSIX -->
<div class="defun">
&mdash; Function: int <b>pthread_mutexattr_init</b> (<var>pthread_mutexattr_t *attr</var>)<var><a name="index-pthread_005fmutexattr_005finit-3733"></a></var><br>
<blockquote><p><code>pthread_mutexattr_init</code> initializes the mutex attribute object
<var>attr</var> and fills it with default values for the attributes.

        <p>This function always returns 0. 
</p></blockquote></div>

<!-- pthread.h -->
<!-- POSIX -->
<div class="defun">
&mdash; Function: int <b>pthread_mutexattr_destroy</b> (<var>pthread_mutexattr_t *attr</var>)<var><a name="index-pthread_005fmutexattr_005fdestroy-3734"></a></var><br>
<blockquote><p><code>pthread_mutexattr_destroy</code> destroys a mutex attribute object,
which must not be reused until it is
reinitialized. <code>pthread_mutexattr_destroy</code> does nothing in the
LinuxThreads implementation.

        <p>This function always returns 0. 
</p></blockquote></div>

   <p>LinuxThreads supports only one mutex attribute: the mutex type, which is
either <code>PTHREAD_MUTEX_ADAPTIVE_NP</code> for &ldquo;fast&rdquo; mutexes,
<code>PTHREAD_MUTEX_RECURSIVE_NP</code> for &ldquo;recursive&rdquo; mutexes,
<code>PTHREAD_MUTEX_TIMED_NP</code> for &ldquo;timed&rdquo; mutexes, or
<code>PTHREAD_MUTEX_ERRORCHECK_NP</code> for &ldquo;error checking&rdquo; mutexes.  As
the <code>NP</code> suffix indicates, this is a non-portable extension to the
POSIX standard and should not be employed in portable programs.

   <p>The mutex type determines what happens if a thread attempts to lock a
mutex it already owns with <code>pthread_mutex_lock</code>. If the mutex is of
the &ldquo;fast&rdquo; type, <code>pthread_mutex_lock</code> simply suspends the calling
thread forever.  If the mutex is of the &ldquo;error checking&rdquo; type,
<code>pthread_mutex_lock</code> returns immediately with the error code
<code>EDEADLK</code>.  If the mutex is of the &ldquo;recursive&rdquo; type, the call to
<code>pthread_mutex_lock</code> returns immediately with a success return
code. The number of times the thread owning the mutex has locked it is
recorded in the mutex. The owning thread must call
<code>pthread_mutex_unlock</code> the same number of times before the mutex
returns to the unlocked state.

   <p>The default mutex type is &ldquo;timed&rdquo;, that is, <code>PTHREAD_MUTEX_TIMED_NP</code>. 
<!-- This doesn't describe how a ``timed'' mutex behaves. FIXME -->

<!-- pthread.h -->
<!-- POSIX -->
<div class="defun">
&mdash; Function: int <b>pthread_mutexattr_settype</b> (<var>pthread_mutexattr_t *attr, int type</var>)<var><a name="index-pthread_005fmutexattr_005fsettype-3735"></a></var><br>
<blockquote><p><code>pthread_mutexattr_settype</code> sets the mutex type attribute in
<var>attr</var> to the value specified by <var>type</var>.

        <p>If <var>type</var> is not <code>PTHREAD_MUTEX_ADAPTIVE_NP</code>,
<code>PTHREAD_MUTEX_RECURSIVE_NP</code>, <code>PTHREAD_MUTEX_TIMED_NP</code>, or
<code>PTHREAD_MUTEX_ERRORCHECK_NP</code>, this function will return
<code>EINVAL</code> and leave <var>attr</var> unchanged.

        <p>The standard Unix98 identifiers <code>PTHREAD_MUTEX_DEFAULT</code>,
<code>PTHREAD_MUTEX_NORMAL</code>, <code>PTHREAD_MUTEX_RECURSIVE</code>,
and <code>PTHREAD_MUTEX_ERRORCHECK</code> are also permitted.

        </blockquote></div>

<!-- pthread.h -->
<!-- POSIX -->
<div class="defun">
&mdash; Function: int <b>pthread_mutexattr_gettype</b> (<var>const pthread_mutexattr_t *attr, int *type</var>)<var><a name="index-pthread_005fmutexattr_005fgettype-3736"></a></var><br>
<blockquote><p><code>pthread_mutexattr_gettype</code> retrieves the current value of the
mutex type attribute in <var>attr</var> and stores it in the location pointed
to by <var>type</var>.

        <p>This function always returns 0. 
</p></blockquote></div>

   </body></html>

