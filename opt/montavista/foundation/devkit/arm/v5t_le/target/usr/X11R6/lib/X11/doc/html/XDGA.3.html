
<!--
  $XFree86$
   
 
-->
<!-- manual page source format generated by PolyglotMan v3.0.8+X.Org, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>XDGA(3) manual page</title>
</head>
<body bgcolor='#efefef' text='black' link='blue' vlink='#551A8B' alink='red'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
XDGA - Client library for the XFree86-DGA extension. 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>#include
&lt;X11/extensions/xf86dga.h&gt;</b> 
<dl>

<dt>Bool </dt>
<dd><b>XDGAQueryExtension</b>( <br>
Display *<i>dpy</i>,<i></i> <br>
int *<i>eventBase</i>,<i></i> <br>
int *<i>errorBase</i>)<i></i> </dd>

<dt>Bool </dt>
<dd><b>XDGAQueryVersion</b>( <br>
Display *<i>dpy</i>,<i></i> <br>
int *<i>majorVersion</i>,<i></i> <br>
int *<i>minorVersion</i>)<i></i> </dd>

<dt>XDGAMode </dt>
<dd>*<b>XDGAQueryModes</b>( <br>
Display *<i>dpy</i>,<i></i> <br>
int <i>screen</i>,<i></i> <br>
int *<i>num</i>)<i></i> </dd>

<dt>XDGADevice </dt>
<dd>*<b>XDGASetMode</b>( <br>
Display *<i>dpy</i>,<i></i> <br>
int <i>screen</i>,<i></i> <br>
int <i>mode</i>)<i></i> </dd>

<dt>Bool </dt>
<dd><b>XDGAOpenFramebuffer</b>( <br>
Display *<i>dpy</i>,<i></i> <br>
int <i>screen</i>)<i></i> </dd>

<dt>void </dt>
<dd><b>XDGACloseFramebuffer</b>( <br>
Display *<i>dpy</i>,<i></i> <br>
int <i>screen</i>)<i></i> </dd>

<dt>void </dt>
<dd><b>XDGASetViewport</b>( <br>
Display *<i>dpy</i>,<i></i> <br>
int <i>screen</i>,<i></i> <br>
int <i>x</i>,<i></i> <br>
int <i>y</i>,<i></i> <br>
int <i>flags</i>)<i></i> </dd>

<dt>void </dt>
<dd><b>XDGAInstallColormap</b>( <br>
Display *<i>dpy</i>,<i></i> <br>
int <i>screen</i>,<i></i> <br>
Colormap <i>cmap</i>)<i></i> </dd>

<dt>Colormap </dt>
<dd><b>XDGACreateColormap</b>( <br>
Display *<i>dpy</i>,<i></i> <br>
int <i>screen</i>,<i></i> <br>
XDGADevice *<i>device</i>,<i></i> <br>
int <i>alloc</i>)<i></i> </dd>

<dt>void </dt>
<dd><b>XDGASelectInput</b>( <br>
Display *<i>dpy</i>,<i></i> <br>
int <i>screen</i>,<i></i> <br>
long <i>event_mask</i>)<i></i> </dd>

<dt>void </dt>
<dd><b>XDGAFillRectangle</b>( <br>
Display *<i>dpy</i>,<i></i> <br>
int <i>screen</i>,<i></i> <br>
int <i>x</i>,<i></i> <br>
int <i>y</i>,<i></i> <br>
unsigned int <i>width</i>,<i></i> <br>
unsigned int <i>height</i>,<i></i> <br>
unsigned long <i>color</i>)<i></i> </dd>

<dt>void </dt>
<dd><b>XDGACopyArea</b>( <br>
Display *<i>dpy</i>,<i></i> <br>
int <i>screen</i>,<i></i> <br>
int <i>srcx</i>,<i></i> <br>
int <i>srcy</i>,<i></i> <br>
unsigned int <i>width</i>,<i></i> <br>
unsigned int <i>height</i>,<i></i> <br>
int <i>dstx</i>,<i></i> <br>
int <i>dsty</i>)<i></i> </dd>

<dt>void </dt>
<dd><b>XDGACopyTransparentArea</b>( <br>
Display *<i>dpy</i>,<i></i> <br>
int <i>screen</i>,<i></i> <br>
int <i>srcx</i>,<i></i> <br>
int <i>srcy</i>,<i></i> <br>
unsigned int <i>width</i>,<i></i> <br>
unsigned int <i>height</i>,<i></i> <br>
int <i>dstx</i>,<i></i> <br>
int <i>dsty</i>,<i></i> <br>
unsigned long <i>key</i>)<i></i> </dd>

<dt>int </dt>
<dd><b>XDGAGetViewportStatus</b>( <br>
Display *<i>dpy</i>,<i></i> <br>
int <i>screen</i>)<i></i> </dd>

<dt>void </dt>
<dd><b>XDGASync</b>( <br>
Display *<i>dpy</i>,<i></i> <br>
int <i>screen</i>)<i></i> </dd>

<dt>Bool </dt>
<dd><b>XDGASetClientVersion</b>( <br>
Display *<i>dpy</i>)<i></i> </dd>

<dt>void </dt>
<dd><b>XDGAChangePixmapMode</b>( <br>
Display *<i>dpy</i>,<i></i> <br>
int <i>screen</i>,<i></i> <br>
int *<i>x</i>,<i></i> <br>
int *<i>y</i>,<i></i> <br>
int <i>mode</i>)<i></i> </dd>

<dt>void </dt>
<dd><b>XDGAKeyEventToXKeyEvent</b>( <br>
XDGAKeyEvent *<i>dk</i>,<i></i> <br>
XKeyEvent *<i>xk</i>)<i></i> 
<p> </dd>
</dl>

<h2><a name='sect2' href='#toc2'>Description</a></h2>
The <b>XFree86-DGA</b> extension is an X server extension
for allowing client programs direct access to the video frame buffer.  This
is a brief description of the programming interface for version 2.0 of the
<b>XFree86-DGA</b> extension. <p>
<b>XFree86-DGA</b> is not intended as a direct rendering API,
but rather, as a mechanism to "get the X Server out of the way" so that
some other direct rendering API can have full access to the hardware.  With
this in mind, DGA does provide clients some direct access to the hardware
without requiring a separate rendering API, but this access is limited
to direct linear framebuffer access. <p>
Most of the reasons for the <b>XFree86-DGA</b>
extension's existence are now better served in other ways.  Further development
of this extension is not expected, and it may be deprecated in a future
release.  The features that continue to be useful will either be provided
through other existing mechanisms, or through an extension that address
those needs more specifically. <p>
<b>XFree86-DGA</b> is initialized by passing a number
corresponding to a valid <i>XDGAMode</i> to <b>XDGASetMode</b>(). Clients can get a list
of valid modes from <b>XDGAQueryModes</b>(). Each <i>XDGAMode</i> corresponds to a different
framebuffer layout. <p>
<b>XDGAQueryModes</b>() returns a pointer to an array of  <i>XDGAMode</i>s
which are valid for the given screen. <i>num</i> is the number of elements in the
array.  The returned array can be freed with <a href='XFree.3.html'>XFree(3)</a>
.  The <i>XDGAMode</i> structure
is as follows: <p>
<br>
<pre>typedef struct {
   int num;
   char *name;
   float verticalRefresh;
   int flags;
   int imageWidth;
   int imageHeight;
   int pixmapWidth;
   int pixmapHeight;
   int bytesPerScanline;
   int byteOrder;
   int depth;
   int bitsPerPixel;
   unsigned long redMask;
   unsigned long greenMask;
   unsigned long blueMask;
   short visualClass;
   int viewportWidth;
   int viewportHeight;
   int xViewportStep;
   int yViewportStep;
   int maxViewportX;
   int maxViewportY;
   int viewportFlags;
   int reserved1;
   int reserved2;

} XDGAMode;
</pre>
<dl>

<dt><i>num</i> </dt>
<dd>A unique identifying number (<i>num</i> &gt; 0) for the mode.  This is the number
referenced when initializing the mode. </dd>

<dt><i>name</i> </dt>
<dd>The name of the corresponding
modeline as given in the xorg.conf file. </dd>

<dt><i>verticalRefresh</i> </dt>
<dd>The vertical refresh
rate for the modeline (in Hz). </dd>

<dt><i>flags</i> </dt>
<dd>Any of the following may be OR'd together:
<blockquote></dd>

<dt><b>XDGAConcurrentAccess</b> </dt>
<dd>Indicates that concurrent client/server access to
the framebuffer is possible.  If this flag is not set it is very important
to call <b>XDGASync</b>() before directly accessing the framebuffer if a call
to <b>XDGAFillRectangle</b>(), <b>XDGACopyArea</b>() or <b>XDGACopyTransparentArea</b>() or
any Xlib rendering function has been made prior to such accesses. </dd>

<dt><b>XDGASolidFillRect</b>
</dt>
<dd>Indicates that <b>XDGAFillRectangle</b>() is supported. </dd>

<dt><b>XDGABlitRect</b> </dt>
<dd>Indicates
that <b>XDGACopyArea</b>() is supported. </dd>

<dt><b>XDGABlitTransRect</b> </dt>
<dd>Indicates that <b>XDGACopyTransparentArea</b>()
is supported. </dd>

<dt><b>XDGAPixmap</b> </dt>
<dd>Indicates that a Pixmap will be returned when the
mode is initialized. This means that rendering with Xlib is possible for
this mode. </dd>

<dt><b>XDGAInterlaced</b> </dt>
<dd></dd>

<dt><b>XDGADoublescan</b> </dt>
<dd>Indicates that the mode is an interlaced
or doublescan mode. </dd>
</dl>
</blockquote>

<dl>

<dt><i>imageWidth</i> </dt>
<dd></dd>

<dt><i>imageHeight</i> </dt>
<dd>The width and height of the framebuffer
area accessible by the client. This rectangle is always justified to the
upper left-hand corner. </dd>

<dt><i>pixmapWidth</i> </dt>
<dd></dd>

<dt><i>pixmapHeight</i> </dt>
<dd>The width and height of
the framebuffer area accessible by Xlib.  This rectangle is always justified
to the upper left-hand corner.  These fields are only valid if the <b>XDGAPixmap</b>
flag is set in the <i>flags</i> field. </dd>

<dt><i>bytesPerScanline</i> </dt>
<dd>The pitch of the framebuffer
in bytes. </dd>

<dt><i>byteOrder</i> </dt>
<dd><b>MSBFirst</b> or <b>LSBFirst</b>. </dd>

<dt><i>depth</i> </dt>
<dd>The number of bits in each
pixel which contain usable data. </dd>

<dt><i>bitsPerPixel</i> </dt>
<dd>The number of bits taken up
by each pixel. </dd>

<dt><i>redMask</i> </dt>
<dd></dd>

<dt><i>greenMask</i> </dt>
<dd></dd>

<dt><i>blueMask</i> </dt>
<dd>The RGB masks.  These do not apply
to color-indexed modes. </dd>

<dt><i>visualClass</i> </dt>
<dd><b>TrueColor</b>, <b>PseudoColor</b>, <b>DirectColor</b>,
etc. </dd>

<dt><i>viewportWidth</i> </dt>
<dd></dd>

<dt><i>viewportHeight</i> </dt>
<dd>The dimensions of the portion of the framebuffer
which will be displayed on the screen. </dd>

<dt><i>xViewPortStep</i> </dt>
<dd></dd>

<dt><i>yViewPortStep</i> </dt>
<dd>The granularity
of the x,y viewport positioning possible with the <b>XDGASetViewport</b>() function.
</dd>

<dt><i>maxViewportX</i> </dt>
<dd></dd>

<dt><i>maxViewportY</i> </dt>
<dd>The maximum x and y positions possible with the
 <b>XDGASetViewport</b>() function. </dd>

<dt><i>viewportFlags</i> </dt>
<dd>Any of the following may be OR'd
together <blockquote></dd>

<dt><b>XDGAFlipRetrace</b> </dt>
<dd>Indicates that the hardware can switch viewports
during the vertical retrace. </dd>

<dt><b>XDGAFlipImmediate</b> </dt>
<dd>Indicates that the hardware
can switch viewports immediately without waiting for the vertical retrace.
</dd>
</dl>
</blockquote>
<p>
<b>XDGASetMode</b>() initialises the <i>XDGAMode</i> corresponding to <i>num</i>. To exit DGA
mode and return to normal server operation, call <b>XDGASetMode</b>() with <i>num</i>
set to zero. <b>XDGASetMode</b>() returns a pointer to an <i>XDGADevice</i> if successful.
 The XDGADevice can be freed with <a href='XFree.3.html'>XFree(3)</a>
.  The <i>XDGADevice</i> structure is
as follows: <p>
<br>
<pre>typedef struct {
   XDGAMode mode;
   unsigned char *data;
   Pixmap pixmap;

} XDGADevice;
</pre>
<dl>

<dt><i>mode</i> </dt>
<dd>The <i>XDGAMode</i> structure, identical to the information returned by <b>XDGAQueryModes</b>().
</dd>

<dt><i>data</i> </dt>
<dd>If direct framebuffer access is desired and possible, this field will
contain a pointer to the mapped framebuffer memory.  Generally, this field
will be zero unless a call to <b>XDGAOpenFramebuffer</b>() is made prior to initialization
of the mode. </dd>

<dt><i>pixmap</i> </dt>
<dd>If the mode supports Xlib rendering as indicated by
<b>XDGAPixmap</b> in the <i>flags</i> field, this will contain a Pixmap handle suitable
for passing as the drawable argument to Xlib functions.  This field will
be zero if Xlib rendering is not supported. </dd>
</dl>
<p>
<b>XDGAQueryExtension</b>() checks
for the presence of the extension and returns the event and error bases.
<p>
<b>XDGAQueryVersion</b>() returns the <b>XFree86-DGA</b> major and minor version numbers.
<p>
<b>XDGAOpenFramebuffer</b>() maps the framebuffer memory.  The client needs sufficient
privileges to be able to do this. <b>XDGAOpenFramebuffer</b>() should be called
prior to initializing a DGA mode if direct framebuffer access is desired
for that mode. <b>XDGAOpenFramebuffer</b>() does not need to be called if direct
framebuffer access is not required. If the framebuffer is opened, <p>
<b>XDGACloseFramebuffer</b>()
should be called prior to client exit to unmap the memory. <p>
<b>XDGAChangePixmapMode</b>()
can be used to change between two pixmap sizes in cases where a Pixmap
is available for Xlib rendering.  The following values for the <i>mode</i> parameter
are available: <blockquote>
<dl>

<dt><b>XDGAPixmapModeLarge</b> </dt>
<dd>The pixmap size is defined by the <i>pixmapWidth</i>
and <i>pixmapHeight</i> fields in the <i>XDGAMode</i> structure.  The <i>x</i> and <i>y</i> values are
ignored in this case. </dd>

<dt><b>XDGAPixmapModeSmall</b> </dt>
<dd>The pixmap size is defined by
the <i>viewportWidth</i> and <i>viewportHeight</i> fields in the <i>XDGAMode</i> structure. 
In this mode, the <i>x</i> and <i>y</i> values specify where in the framebuffer this
pixmap rectangle is located. It may be placed anywhere within the Xlib renderable
region described by the <i>pixmapWidth</i> and <i>pixmapHeight</i> fields in the <i>XDGAMode</i>.
The <i>x</i> and <i>y</i> values returned are the resultant location of the pixmap and
may be different from the requested x,y location due to platform specific
alignment constraints.  All Xlib rendering is clipped to this pixmap rectangle.
</dd>
</dl>
</blockquote>
<p>
<b>XDGASetViewport</b>() sets the upper left-hand corner of the rectangle of framebuffer
that is to be displayed on the screen.  Not all locations may be supported
by the hardware and requested locations will be adjusted according to the
<i>xViewPortStep</i> and <i>yViewPortStep</i> fields in the <i>XDGAMode</i>. <p>
<i>flags</i> can be <b>XDGAFlipRetrace</b>
or <b>XDGAFlipImmediate</b> to adjust the viewport location at the next vertical
retrace or immediately.  Values other than the supported values advertised
in the mode's <i>viewportFlags</i> field will result in hardware-specific default
behavior. <b>XDGAFlipImmediate</b> will block until the flip is completed. <b>XDGAFlipRetrace</b>
will generally NOT block so it is necessary to monitor the viewport status
with <b>XDGAGetViewportStatus</b>(). <b>XDGAFlipImmediate</b> requests during pending
<b>XDGAFlipRetrace</b> requests will be ignored. <p>
<b>XDGAGetViewportStatus</b>() keeps
track of the <b>XDGASetViewport</b>() requests still pending.  The return value
of the function will have consecutive bits set (LSB justified), each bit
representing a pending viewport change.  For example: <p>
<br>
<pre>     while(XDGAGetViewportStatus(dpy, screen));
</pre><p>
waits for all pending viewport changes to finish. <p>
<br>
<pre>     while(0x2 &amp; XDGAGetViewportStatus(dpy, screen));
</pre><p>
waits until all but the last viewport changes have completed. <p>
<b>XDGACreateColormap</b>()
is similar to the Xlib function <a href='XCreateColormap.3.html'>XCreateColormap(3)</a>
 except that it takes
an <i>XDGADevice</i> as an argument instead of a Window and Visual.  Though <a href='XCreateColormap.3.html'>XCreateColormap(3)</a>

may create usable colormaps in some cases, <b>XDGACreateColormap</b>() is the
preferred method for creating colormaps in DGA since there may not be an
advertised visual compatible with the DGA device. <p>
<b>XDGAInstallColormap</b>()
must be used to install colormaps in DGA mode.  <a href='XInstallColormap.3.html'>XInstallColormap(3)</a>
 will
not work. <p>
<b>XDGASelectInput</b>() enables DGA's own event mechanism.  This function
is similar to <a href='XSelectInput.3.html'>XSelectInput(3)</a>
, and all Xlib Key, Button and Motion masks
are supported. The following DGA events are defined: <p>
<br>
<pre>typedef struct {
   int type;             /* ButtonPress or ButtonRelease + the DGA event
base*/
   unsigned long serial; /* # or last request processed by the server */
   Display *display;     /* Display the event was read from */
   int screen;           /* The screen number the event came from */
   Time time;            /* milliseconds */
   unsigned int state;   /* key or button mask */
   unsigned int button;  /* detail */

} XDGAButtonEvent;
</pre><p>
<br>
<pre>typedef struct {
   int type;             /* KeyPress or KeyRelease + the DGA event base*/
   unsigned long serial; /* # or last request processed by the server */
   Display *display;     /* Display the event was read from */
   int screen;           /* The screen number the event came from */
   Time time;            /* milliseconds */
   unsigned int state;   /* key or button mask */
   unsigned int keycode; /* detail */

} XDGAKeyEvent;
</pre><p>
<br>
<pre>typedef struct {
   int type;             /* MotionNotify + the DGA event base*/
   unsigned long serial; /* # or last request processed by the server */
   Display *display;     /* Display the event was read from */
   int screen;           /* The screen number the event came from */
   Time time;            /* milliseconds */
   unsigned int state;   /* key or button mask */
   int dx;               /* relative pointer motion */
   int dy;               /* relative pointer motion */

} XDGAMotionEvent;
</pre><p>
<b>XDGAKeyEventToXKeyEvent</b>() is a helper function to translate <i>XDGAKeyEvent</i>s
into <i>XKeyEvent</i>s suitable for use with <a href='XLookupKeysym.3.html'>XLookupKeysym(3)</a>
. <p>
<b>XDGAFillRectangle</b>(),
<b>XDGACopyArea</b>(), and <b>XDGACopyTransparentArea</b>() are included with some reservation
since DGA is not intended as a rendering API.  These are merely convenience
routines and are optionally supported.  The associated flags will be set
in the <i>XDGAMode</i>'s <i>flags</i> field if these functions are supported.  These functions
will be no-ops otherwise. they do not provide direct access to the hardware,
but are simply context-less operations performed by the server. <p>
<b>XDGASync</b>()
blocks until all server rendering to the framebuffer completes.  If Xlib
or the 3 rendering functions above are used, <b>XDGASync</b>() must be called
before the client directly accesses the framebuffer as the server rendering
is asynchronous with the client and may have not completed.  This is especially
important if the <b>XDGAConcurrentAccess</b> flag is not set in the <i>XDGAMode</i>'s
<i>flags</i> field since concurrent access by the server and client may result
in a system lockup. 
<h2><a name='sect3' href='#toc3'>See Also</a></h2>
<a href='Xorg.3.html'>Xorg(3x)</a>
, <a href='xorg.conf.5.html'>xorg.conf(5x)</a>
 
<h2><a name='sect4' href='#toc4'>Authors</a></h2>
<b>XFree86-DGA</b> version
2 was written by Mark Vojkovich.  Version 1 was written by Jon Tombs, Harm
Hanemaayer, Mark Vojkovich. 
<p> <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>See Also</a></li>
<li><a name='toc4' href='#sect4'>Authors</a></li>
</ul>
</body>
</html>
