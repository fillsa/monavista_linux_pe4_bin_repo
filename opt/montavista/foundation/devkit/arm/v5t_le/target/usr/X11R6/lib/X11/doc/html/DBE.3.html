
<!--
  $Xorg: DBE.man,v 1.3 2000/08/17 19:41:55 cpqbld Exp $
   
   Copyright (c) 1995  Hewlett-Packard Company
   
   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the "Software"), 
   to deal in the Software without restriction, including without limitation 
   the rights to use, copy, modify, merge, publish, distribute, sublicense, 
   and/or sell copies of the Software, and to permit persons to whom the 
   Software furnished to do so, subject to the following conditions:
   
   The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.
   
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL 
   HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF 
   OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
   SOFTWARE.
   
   Except as contained in this notice, the name of the Hewlett-Packard Company shall not 
   be used in advertising or otherwise to promote the sale, use or other 
   dealing in this Software without prior written authorization from the 
   Hewlett-Packard Company.
   
   $XFree86: xc/doc/man/Xext/dbe/DBE.man,v 3.4 2001/01/27 18:20:19 dawes Exp $
   
 
-->
<!-- manual page source format generated by PolyglotMan v3.0.8+X.Org, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>DBE(3X11) manual page</title>
</head>
<body bgcolor='#efefef' text='black' link='blue' vlink='#551A8B' alink='red'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
DBE - Double Buffer Extension 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
The
Double Buffer Extension (DBE) provides a standard way to utilize double-buffering
within the framework of the X Window System. Double-buffering uses two buffers,
called front and back, which hold images. The front buffer is visible to
the user; the back buffer is not.  Successive frames of an animation are
rendered into the back buffer while the previously rendered frame is displayed
in the front buffer.  When a new frame is ready, the back and front buffers
swap roles, making the new frame visible.  Ideally,  this exchange appears
to happen instantaneously to the user, with no visual artifacts.  Thus,
only completely rendered images are presented to the user,  and remain
visible during the entire time it takes to render a new frame.  The result
is a flicker-free animation. 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
<b>Concepts</b> <blockquote>Normal windows are created
using <b>XCreateWindow()</b> or <b>XCreateSimpleWindow(),</b> which allocate a set of
window attributes and, for InputOutput windows, a front buffer, into which
an image can be drawn.  The contents of this buffer will be  displayed when
the window is visible. 
<p> This extension enables applications to use double-buffering
with a window. This involves creating a second buffer, called a back buffer,
and associating one or more back buffer names <i>(XIDs)</i> with the window, for
use when referring  to (i.e., drawing to or reading from) the window's back
buffer. The back buffer name is a drawable of type <i>XdbeBackBuffer.</i> 
<p> DBE provides
a relative double-buffering model.  One XID, the window, always refers to
the front buffer.  One or more other XIDs, the back buffer names, always
refer to the back buffer.  After a buffer swap, the window  continues to
refer to the (new) front buffer, and the back buffer name continues to
refer to the (new) back buffer.  Thus, applications and toolkits that want
to just render to the back buffer always use the back buffer name for all
drawing requests to the window.  Portions of an application that want to
render to the front buffer always use the window XID for all drawing  requests
to the window. 
<p> Multiple clients and toolkits can all use double-buffering
on the same window. DBE does not provide a request for querying whether
a window has  double-buffering support, and if so, what the back buffer
name is.  Given the  asynchronous nature of the X Window System, this would
cause race conditions.  Instead, DBE allows multiple back buffer names to
exist for the  same window; they all refer to the same physical back buffer.
 The first time a  back buffer name is allocated for a window, the window
becomes double-buffered and the back buffer name is associated with the
window. Subsequently, the window already is a double-buffered window, and
nothing about the window changes when a new back buffer name is allocated,
except that the new back buffer name is associated with the window.  The
window remains double-buffered until either the window is destroyed, or
until all of the back buffer names for the window are deallocated. 
<p> In general,
both the front and back buffers ae treated the same.  In  particular, here
are some important characteristics: 
<p> <blockquote>Only one buffer per window can be
visible at a time (the front buffer). 
<p> Both buffers associated with a window
have the same visual type, depth, width, height, and shape as the window.

<p> Both buffers associated with a window are "visible" (or "obscured") in
the same way.  When an Expose event is generated for a window, this  event
is considered to apply to both buffers equally.  When a  double-buffered
window is exposed, both buffers are tiled with the  window background. Even
though the back buffer is not visible, terms such as obscure apply to the
 back buffer as well as to the front buffer. 
<p> It is acceptable at any time
to pass an <i>XdbeBackBuffer</i> in any function that expects a drawable. This
enables an application to draw directly into <i>XdbeBackBuffer</i> in the same
fashion as it would draw into any other drawable. 
<p> It is an error (Window)
to pass an <i>XdbeBackBuffer</i> in a function that expects a Window. 
<p> An <i>XdbeBackBuffer</i>
will never be sent in a reply, event, or error where a Window is specified.

<p> If backing-store and save-under applies to a double-buffered window, it applies
to both buffers equally. 
<p> If the <b>XClearArea()</b> or <b>XClearWindow()</b> function
is executed on a double-buffered window, the same area in both the front
and back buffers is cleared. </blockquote>

<p> The effect of passing a window to a function
that accepts a drawable is unchanged by this extension.  The window and
front buffer are synonymous with each other.  This includes obeying the
<b>XGetImage()</b> and <b>XGetSubImage()</b> semantics and the subwindow-mode semantics
if a graphics context is involved.  Regardless of whether the window was
explicitly passed in an <b>XGetImage()</b> or <b>XGetSubImage()</b> call, or implicitly
referenced (i.e., one of the window's ancestors was passed in the function),
the front (i.e. visible) buffer is always referenced. Thus, DBE-naive screen
dump clients will always get the front buffer. <b>XGetImage()</b> and <b>XGetSubImage()</b>
on a back buffer return undefined image contents for any obscured regions
of the back buffer that fall within the image. 
<p> Drawing to a back buffer
always uses the clip region that would be used to  draw to the front buffer
with a GC subwindow-mode of ClipByChildren.  If an  ancestor of a double-buffered
window is drawn to with a GC having a subwindow-mode of IncludeInferiors,
the effect on the double-buffered window's back buffer depends on the depth
of the double-buffered window and the ancestor.  If the depths are the same,
the contents of the back buffer of the double-buffered window are not changed.
 If the depths are different, the contents of the back buffer of the double-buffered
window are undefined  for the pixels that the IncludeInferiors drawing
touched. 
<p> DBE adds no new events.  DBE does not extend the semantics of any
existing events with the exception of adding a new drawable type called
<i>XdbeBackBuffer.</i> 
<p> If events, replies, or errors that contain a drawable (e.g.,
GraphicsExpose) are generated in response to a request, the drawable returned
will be the one specified in the request. 
<p> DBE advertises which visuals
support double buffering. 
<p> DBE does not include any timing or synchronization
facilities.  Applications that need such facilities (e.g., to maintain a constant
frame rate) should investigate the Synchronization Extension, an X Consortium
standard. </blockquote>

<p> <b>Window Management Operations</b> 
<p> <blockquote>The basic philosophy of DBE is
that both buffers are treated the same by X window management operations.

<p> When a double-buffered window is destroyed, both buffers associated with
the window are destroyed, and all back buffer names associated with the
window are freed. 
<p> If the size of a double-buffered window changes, both
 buffers assume the new size.  If the window's size increases, the effect
on the  buffers depends on whether the implementation honors bit gravity
for buffers. If bit gravity is implemented, then the contents of both buffers
are moved in  accordance with the window's bit gravity, and the remaining
areas are tiled with the window background.  If  bit gravity is not implemented,
then the entire unobscured region of both  buffers is tiled with the window
background.  In either case, Expose events are generated for the region
that is tiled with the window background. 
<p> If the <b>XGetGeometry()</b> function
is executed on an <i>XdbeBackBuffer,</i> the returned x, y, and border-width will
be zero. 
<p> If the Shape extension <b>ShapeRectangles, ShapeMask, ShapeCombine,</b>
or <b>ShapeOffset</b> request is executed on a double-buffered window, both  buffers
are reshaped to match the new window shape.  The region difference D = new
shape - old shape is tiled with the window background in both  buffers,
and Expose events are generated for D. </blockquote>

<p> <b>Complex Swap Actions</b> 
<p> <blockquote>DBE has no
explicit knowledge of ancillary buffers (e.g. depth buffers or  alpha buffers),
and only has a limited set of defined swap actions.  Some applications may
need a richer set of swap actions than DBE provides.  Some  DBE implementations
have knowledge of ancillary buffers, and/or can provide  a rich set of
swap actions. Instead of continually extending DBE to increase its set of
swap actions, DBE provides a flexible "idiom" mechanism.  If an  applications's
needs are served by the defined swap actions, it should use them; otherwise,
it should use the following method of expressing a complex swap action
as an idiom.  Following this policy will ensure the best possible performance
across a wide variety of implementations. 
<p> As suggested by the term "idiom,"
a complex swap action should be expressed  as a group/series of requests.
 Taken together, this group of requests may be  combined into an atomic
operation by the implementation, in order to  maximize performance.  The
set of idioms actually recognized for optimization is implementation dependent.
 To help with idiom expression and  interpretation, an idiom must be surrounded
by two function calls:   <b>XdbeBeginIdiom()</b> and <b>XdbeEndIdiom().</b> Unless this
begin-end pair surrounds the idiom, it may not be recognized by a given
implementation, and  performance will suffer. 
<p> For example, if an application
wants to swap buffers for two windows, and use X to clear only certain
planes of the back buffers, the application would make the following calls
as a group, and in the following order: 
<p> <blockquote><b>XdbeBeginIdiom().</b> 
<p> <b>XdbeSwapBuffers()</b>
with XIDs for two windows, each of which uses a swap action of Untouched.

<p> <b>XFillRectangle()</b> to the back buffer of one window. 
<p> <b>XFillRectangle()</b> to
the back buffer of the other window. 
<p> <b>XdbeEndIdiom().</b> </blockquote>

<p> The <b>XdbeBeginIdiom()</b>
and <b>XdbeEndIdiom()</b> functions do not perform any actions themselves.  They
are treated as markers by implementations that can  combine certain groups/series
of requests as idioms, and are ignored by other implementations or for
non-recognized groups/series of requests.  If these function calls are made
out of order, or are mismatched, no errors are sent, and the functions
are executed as usual, though performance may suffer. 
<p> <b>XdbeSwapBuffers()</b>
need not be included in an idiom.  For example, if a swap action of Copied
is desired, but only some of the planes should be copied, <b>XCopyArea()</b> may
be used instead of  <b>XdbeSwapBuffers().</b> If <b>XdbeSwapBuffers()</b> is included
in an idiom, it should immediately follow the <b>XdbeBeginIdiom()</b> call.  Also,
when the  <b>XdbeSwapBuffers()</b> is included in an idiom, that request's swap
action will  still be valid, and if the swap action might overlap with
another request, then  the final result of the idiom must be as if the
separate requests were executed serially.  For example, if the specified
swap action is Untouched, and if a  <b>XFillRectangle()</b> using a client clip
rectangle is done to the window's back buffer after the <b>XdbeSwapBuffers()</b>
call, then the contents of the new  back buffer (after the idiom) will
be the same as if the idiom was not recognized by the implementation. 
<p> It
is highly recommended that API providers define, and application  developers
use, "convenience" functions that allow client applications to call one
procedure that encapsulates common idioms.  These functions will generate
the <b>XdbeBeginIdiom(),</b> idiom, and  <b>XdbeEndIdiom()</b> calls.  Usage of these
functions will ensure best possible performance across a wide variety of
implementations. </blockquote>

<h2><a name='sect3' href='#toc3'>See Also</a></h2>
<i>XdbeAllocateBackBufferName(),</i> <i>XdbeBeginIdiom(),</i>
<i>XdbeDeallocateBackBufferName(),</i> <i>XdbeEndIdiom(),</i> <i>XdbeFreeVisualInfo(),</i> <i>XdbeGetBackBufferAttributes(),</i>
<i>XdbeGetVisualInfo(),</i> <i>XdbeQueryExtension(),</i> <i>XdbeSwapBuffers().</i> 
<p> <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>See Also</a></li>
</ul>
</body>
</html>
