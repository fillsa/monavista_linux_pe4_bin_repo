<!-- manual page source format generated by PolyglotMan v3.0.8+X.Org, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>DUMPKEYMAP(1) manual page</title>
</head>
<body bgcolor='#efefef' text='black' link='blue' vlink='#551A8B' alink='red'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
dumpkeymap - Dianostic dump of a .keymapping file 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>dumpkeymap</b>
[<i>options</i>] [-] [<i>file</i>...]<i></i> 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
<i>dumpkeymap</i> prints a textual representation
of each Apple/<font size='-1'>NeXT</font>
 <i>.keymapping</i> file mentioned on the command-line.  If no
files are mentioned and if the local machine is an Apple or <font size='-1'>NeXT</font>
 installation,
then the key mapping currently in use by the WindowServer and the AppKit
is printed instead. 
<h2><a name='sect3' href='#toc3'>Options</a></h2>

<dl>

<dt><b>-h --help</b> </dt>
<dd>Display general program instructions and
option summary. </dd>

<dt><b>-k --help-keymapping</b> </dt>
<dd>Display a detailed description of the internal
layout of a <i>.keymapping</i> file.  This is the same information as that presented
in the <i>Key Mapping Description</i> section of this document. </dd>

<dt><b>-o --help-output</b> </dt>
<dd>Display
an explanation of the output generated by <i>dumpkeymap</i> when dissecting a
<i>.keymapping</i> file.  This is the same information as that presented in the
<i>Output Description</i> section of this document. </dd>

<dt><b>-f --help-files</b> </dt>
<dd>Display a summary
of the various files and directories which are related to key mappings.
 This is the same information as that presented in the <i>Files</i> section of
this document. </dd>

<dt><b>-d --help-diagnostics</b> </dt>
<dd>Display a list of the various diagnostic
messages which may be emitted by <i>dumpkeymap.</i> This is the same information
as that presented in the <i>Diagnostics</i> section of this document. </dd>

<dt><b>-v --version</b>
</dt>
<dd>Display the <i>dumpkeymap</i> version number and warranty information. </dd>

<dt><b>- --</b> </dt>
<dd>Inhibit
processing of options at this point in the argument list.  An occurrence
of `-' or `--' in the argument list causes all following arguments to be treated
as file names even if an argument begins with a `-' character. </dd>
</dl>

<h2><a name='sect4' href='#toc4'>Key Mapping
Description</a></h2>
The following sections describe, in complete detail, the format
of a raw key mapping resource, as well as the format of the <i>.keymapping</i>
file which encapsulates one or more raw mappings. 
<h2><a name='sect5' href='#toc5'>Types and Data</a></h2>
The following
type definitions are employed throughout this discussion: <p>
<blockquote><br>
<pre>typedef unsigned char byte;
typedef unsigned short word;
typedef unsigned long dword;
</pre> </blockquote>
<p>
Additionally, the type definition `<i>number</i>'<i></i> is used generically to indicate
a numeric value.  The actual size of the `<i>number</i>'<i></i> type may be one or two bytes
depending upon how the data is stored in the key map.  Although most key
maps use byte-sized numeric values, word-sized values are also allowed. <p>
Multi-byte
values in a key mapping file are stored in big-endian byte order. 
<h2><a name='sect6' href='#toc6'>Key Mapping
File and Device Mapping</a></h2>
A key mapping file begins with a magic-number and
continues with a variable number of device-specific key mappings. <p>
<blockquote><br>
<pre>struct KeyMappingFile {
    char magic_number[4];    // `KYM1'
    DeviceMapping maps[...]; // Variable number of maps
};
</pre> <p>
<br>
<pre>struct DeviceMapping {
    dword interface;  // Interface type
    dword handler_id; // Interface subtype
    dword map_size;   // Byte count of `map' (below)
    KeyMapping map; 
};
</pre> </blockquote>
<p>
The value of `interface' represents a family of keyboard device types (such
as Intel <font size='-1'>"PC, ADB, NeXT,"</font>
 Sun Type5, etc.), and is generally specified as
one of the constant values <font size='-1'>"NX_EVS_DEVICE_INTERFACE_ADB, NX_EVS_DEVICE_INTERFACE_ACE,"</font>

etc., which are are defined in IOHIDTypes.h on MacOS/X and Darwin, and in
ev_types.h on MacOS/X Server, OpenStep, and NextStep. <p>
The value of `handler_id'
represents a specific keyboard layout within the much broader `interface'
family.  For instance, for a 101-key Intel <font size='-1'>PC</font>
 keyboard (of type <font size='-1'>NX_EVS_DEVICE_INTERFACE_ACE</font>
)
the `handler_id' is '0', whereas for a 102-key keyboard it is `1'. <p>
Together, `interface'
and `handler_id' identify the exact keyboard hardware to which this mapping
applies.  Programs which display a visual representation of a keyboard layout,
match `interface' and `handler_id' from the <i>.keymapping</i> file against the `interface'
and `handler_id' values found in each <i>.keyboard</i> file. 
<h2><a name='sect7' href='#toc7'>Key Mapping</a></h2>
A key mapping
completely defines the relationship of all scan codes with their associated
functionality.  A <i>KeyMapping</i> structure is embedded within the <i>DeviceMapping</i>
structure in a <i>KeyMappingFile</i>. The key mapping currently in use by the WindowServer
and AppKit is also represented by a <i>KeyMapping</i> structure, and can be referred
to directly by calling NXGetKeyMapping() and accessing the `mapping' data
member of the returned <i>NXKeyMapping</i> structure. <p>
<blockquote><br>
<pre>struct KeyMapping {
    word number_size;           // 0=1 byte, non-zero=2 bytes
    number num_modifier_groups; // Modifier groups
    ModifierGroup modifier_groups[...];
    number num_scan_codes;      // Scan groups
    ScanGroup scan_table[...]; 
    number num_sequence_lists;  // Sequence lists
    Sequence sequence_lists[...]; 
    number num_special_keys;    // Special keys
    SpecialKey special_key[...]; 
};
</pre> </blockquote>
<p>
The `number_size' flag determines the size, in bytes, of all remaining numeric
values (denoted by the type definition `<i>number</i>')<i></i> within the key mapping. 
If its value is zero, then numbers are represented by a single byte.  If
it is non-zero, then numbers are represented by a word (two bytes). 
<h2><a name='sect8' href='#toc8'>Modifier
Group</a></h2>
A modifier group defines all scan codes which map to a particular
type of modifier, such as <i>shift</i>, <i>control</i>, etc. <p>
<blockquote><br>
<pre>enum Modifier {
    ALPHALOCK = 0,
    SHIFT,
    CONTROL,
    ALTERNATE,
    COMMAND,
    KEYPAD,
    HELP
};
</pre> <p>
<br>
<pre>struct ModifierGroup {
    number modifier;        // A Modifier constant
    number num_scan_codes; 
    number scan_codes[...]; // Variable number of scan codes
};
</pre> </blockquote>
<p>
The scan_codes[] array contains a list of all scan codes which map to
the specified modifier.  The <i>shift</i>, <i>command</i>, and <i>alternate</i> modifiers are
frequently mapped to two different scan codes, apiece, since these modifiers
often appear on both the left and right sides of the keyboard. 
<h2><a name='sect9' href='#toc9'>Scan Group</a></h2>
There
is one <i>ScanGroup</i> for each scan code generated by the given keyboard.  This
number is given by KeyMapping::num_scan_codes.  The first scan group represents
hardware scan code 0, the second represents scan code 1, etc. <p>
<blockquote><br>
<pre>enum ModifierMask {
    ALPHALOCK_MASK       = 1 &lt;&lt; 0,
    SHIFT_MASK           = 1 &lt;&lt; 1,
    CONTROL_MASK         = 1 &lt;&lt; 2,
    ALTERNATE_MASK       = 1 &lt;&lt; 3,
    CARRIAGE_RETURN_MASK = 1 &lt;&lt; 4
};
#define NOT_BOUND 0xff
</pre> <p>
<br>
<pre>struct ScanGroup {
    number mask; 
    Character characters[...]; 
};
</pre> </blockquote>
<p>
For each scan code, `mask' defines which modifier combinations generate
characters.  If `mask' is <font size='-1'>NOT_BOUND</font>
 (0xff) then then this scan code does not
generate any characters ever, and its characters[] array is zero length.
 Otherwise, the characters[] array contains one <i>Character</i> record for each
modifier combination. <p>
The number of records in characters[] is determined
by computing (1 &lt;&lt; bits_set_in_mask).  In other words, if mask is zero, then
zero bits are set, so characters[] contains only one record.  If `mask' is
<font size='-1'>"(SHIFT_MASK | CONTROL_MASK),"</font>
 then two bits are set, so characters[] contains
four records. <p>
The first record always represents the character which is
generated by that key when no modifiers are active.  The remaining records
represent characters generated by the various modifier combinations.  Using
the example with the <i>shift</i> and <i>control</i> masks set, record two would represent
the character with the <i>shift</i> modifier active; record three, the <i>control</i>
modifier active; and record four, both the <i>shift</i> and <i>control</i> modifiers
active. <p>
As a special case, <font size='-1'>ALPHALOCK_MASK</font>
 implies <font size='-1'>SHIFT_MASK,</font>
 though only
<font size='-1'>ALPHALOCK_MASK</font>
 appears in `mask'.  In this case the same character is generated
for both the <i>shift</i> and <i>alpha-lock</i> modifiers, but only needs to appear once
in the characters[] array. <p>
<font size='-1'>CARRIAGE_RETURN_MASK</font>
 does not actually refer
to a modifier key.  Instead, it is used to distinguish the scan code which
is given the special pseudo-designation of <i>carriage return</i> key.  Typically,
this mask appears solo in a <i>ScanGroup</i> record and only the two <i>Character</i>
records for control-M and control-C follow.  This flag may be a throwback
to an earlier time or may be specially interpreted by the low-level keyboard
driver, but its purpose is otherwise enigmatic. 
<h2><a name='sect10' href='#toc10'>Character</a></h2>
Each <i>Character</i>
record indicates the character generated when this key is pressed, as well
as the character set which contains the character.  Well known character
sets are <font size='-1'>`ASCII'</font>
 and `Symbol'.  The character set can also be one of the meta
values <font size='-1'>FUNCTION_KEY</font>
 or <font size='-1'>KEY_SEQUENCE.</font>
 If it is <font size='-1'>FUNCTION_KEY</font>
 then `char_code'
represents a generally well-known function key such as those enumerated
by <i>FunctionKey.</i> If the character set is <font size='-1'>KEY_SEQUENCE</font>
 then `char_code' represents
is a zero-base index into KeyMapping::sequence_lists[]. <p>
<blockquote><br>
<pre>enum CharacterSet {
    ASCII        = 0x00,
    SYMBOL       = 0x01,
    ... 
    FUNCTION_KEY = 0xfe,
    KEY_SEQUENCE = 0xff
};
</pre> <p>
<br>
<pre>struct Character {
    number set;       // CharacterSet of generated character
    number char_code; // Actual character generated
};
</pre> <p>
<br>
<pre>enum FunctionKey {
    F1 = 0x20, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12,
    INSERT, DELETE, HOME, END, PAGE_UP, PAGE_DOWN, PRINT_SCREEN,
    SCROLL_LOCK, PAUSE, SYS_REQUEST, BREAK, RESET, STOP, MENU,
    USER, SYSTEM, PRINT, CLEAR_LINE, CLEAR_DISPLAY, INSERT_LINE,
    DELETE_LINE, INSERT_CHAR, DELETE_CHAR, PREV, NEXT, SELECT
};
</pre> </blockquote>

<h2><a name='sect11' href='#toc11'>Sequence</a></h2>
When Character::set contains the meta value <font size='-1'>KEY_SEQUENCE,</font>
 the
scan code is bound to a sequence of keys rather than a single character.
A sequence is a series of modifiers and characters which are automatically
generated when the associated key is depressed. <p>
<blockquote><br>
<pre>#define MODIFIER_KEY 0xff
</pre> <p>
<br>
<pre>struct Sequence {
    number num_chars; 
    Character characters[...]; 
};
</pre> </blockquote>
<p>
Each generated <i>Character</i> is represented as previously described, with
the exception that <font size='-1'>MODIFIER_KEY</font>
 may appear in place of <font size='-1'>KEY_SEQUENCE.</font>
 When
the value of Character::set is <font size='-1'>MODIFIER_KEY</font>
 then Character::char_code represents
a modifier key rather than an actual character.  If the modifier represented
by `char_code' is non-zero, then it indicates that the associated modifier
key has been depressed.  In this case, the value is one of the constants
enumerated by <i>Modifier</i> (<font size='-1'>"SHIFT, CONTROL, ALTERNATE,"</font>
 etc.).  If the value
is zero then it means that the modifier keys have been released. 
<h2><a name='sect12' href='#toc12'>Special
Key</a></h2>
A special key is one which is scanned directly by the Mach kernel rather
than by the WindowServer.  In general, events are not generated for special
keys. <p>
<blockquote><br>
<pre>enum SpecialKeyType {
    VOLUME_UP = 0,
    VOLUME_DOWN,
    BRIGHTNESS_UP,
    BRIGHTNESS_DOWN,
    ALPHA_LOCK,
    HELP,
    POWER,
    SECONDARY_ARROW_UP,
    SECONDARY_ARROW_DOWN
};
</pre> <p>
<br>
<pre>struct SpecialKey {
    number type;      // A SpecialKeyType constant
    number scan_code; // Actual scan code
};
</pre> </blockquote>

<h2><a name='sect13' href='#toc13'>Output</a></h2>
What follows is an explanation and description of the various pieces
of information emitted by <i>dumpkeymap.</i> <p>
For a more thorough discussion of
any particular piece of information described here, refer to the detailed
description of the internal layout of a key mapping provided by the <i>Key
Mapping Description</i> section above. 
<h2><a name='sect14' href='#toc14'>Conventions</a></h2>
Depending upon context, some
numeric values are displayed in decimal notation, whereas others are displayed
in hexadecimal notation. Hexadecimal numbers are denoted by a `0x' prefix
(for instance, `0x7b'), except when explicitly noted otherwise. 
<h2><a name='sect15' href='#toc15'>Key Mapping
Source</a></h2>
The first piece of information presented about a particular key mapping
is the source from which the data was gleaned.  For a <i>.keymapping</i> file, the
title <font size='-1'>"`KEYMAP FILE'"</font>
 is emitted along with the path and name of the file
in question.  For the key mapping currently in use by the WindowServer and
AppKit, the title <font size='-1'>"`ACTIVE KEYMAP'"</font>
 is emitted instead. 
<h2><a name='sect16' href='#toc16'>Device Information</a></h2>
Each
<i>.keymapping</i> file may contain one or more raw key mappings.  For example,
a file which maps keys to a Dvorak-style layout might contain raw mappings
for Intel <font size='-1'>"PC, ADB, NeXT,"</font>
 and Sun Type5 keyboards. <p>
For each raw mapping,
the following information is emitted: <p>
<blockquote> 
<ul>
&nbsp;<li>The title <font size='-1'>`KEYMAP'</font>
 along with the
mapping's relative position in the <i>.keymapping</i> file. </li>&nbsp;<li>The `interface' identifier.
</li>&nbsp;<li>The `handler_id' sub-identifier. </li>&#183;&nbsp;<li>The size of the raw mapping resource counted
in bytes. </li>
</ul>
</blockquote>
<p>
 The `interface' and `handler_id' values, taken together, define a
specific keyboard device.  A <i>.keyboard</i> file, which describes the visual layout
of a keyboard, also contains `interface' and `handler_id' identifiers.  The
<i>.keyboard</i> file corresponding to a particular key mapping can be found by
matching the `interface' and `handler_id' values from each resource. 
<h2><a name='sect17' href='#toc17'>Modifiers</a></h2>
Each
mapping may contain zero or more modifier records which associate hardware
scan codes with modifier descriptions such as <i>shift, control, alternate,</i>
etc.  The title <font size='-1'>`MODIFIERS'</font>
 is printed along with the count of modifier records
which follow.  For each modifier record, the modifier's name is printed along
with a list of scan codes, in hexadecimal format, which generate that modifier
value.  For example: <p>
<blockquote><br>
<pre>MODIFIERS [4]
alternate: 0x1d 0x60
control: 0x3a
keypad: 0x52 0x53 ... 0x63 0x62
shift: 0x2a 0x36
</pre></blockquote>

<h2><a name='sect18' href='#toc18'>Characters</a></h2>
Each mapping may contain zero or more character records which
associate hardware scan codes with the actual characters generated by those
scan codes in the presence or absence of various modifier combinations.
 The title <font size='-1'>`CHARACTERS'</font>
 is printed along with the count of character records
which follow.  Here is a highly abbreviated example: <p>
<blockquote><br>
<pre>CHARACTERS [9]
scan 0x00: -AC-L  "a" "A" "^A" "^A" ca c7 "^A" "^A"
scan 0x07: -AC-L  "x" "X" "^X" "^X" 01/b4 01/ce "^X" "^X"
scan 0x0a: ---S-  "&lt;" "&gt;"
scan 0x13: -ACS-  "2" "@" "^@" "^@" b2 b3 "^@" "^@"
scan 0x24: R----  "^M" "^C"
scan 0x3e: -----  [F4]
scan 0x4a: -----  [page up]
scan 0x60: -----  {seq#3}
scan 0x68: not-bound
</pre></blockquote>
<p>
For each record, the hexadecimal value of the hardware scan code is printed,
followed by a list of modifier flag combinations and the actual characters
generated by this scan code with and without modifiers applied. <p>
The modifier
flags field is composed of a combination of single letter representations
of the various modifier types.  The letters stand for: <p>
<blockquote><br>
<pre>L - alpha-lock
S - shift
C - control
A - alternate
R - carriage-return
</pre></blockquote>
<p>
As a special case, the <i>alpha-lock</i> flag also implies the <i>shift</i> flag, so these
two flags never appear together in the same record. <p>
The combination of modifier
flags determines the meaning and number of fields which follow.  The first
field after the modifier flags always represents the character that will
be generated if no modifier keys are depressed.  The remaining fields represent
characters generated by the various modifier combinations.  The order of
the fields follows this general pattern: <p>
<blockquote> 
<ul>
&nbsp;<li>The character generated by this
scan code when no modifiers are in effect is listed first. </li>&nbsp;<li>If the `L' or `S'
flag is active, then the shifted character generated by this scan code
is listed next. </li>&nbsp;<li>If the `C' flag is active, then the control-character generated
by this scan code is listed next.  Furthermore, if the `L' or `S' flag is also
active, then the shifted control-character is listed after that. </li>&nbsp;<li>If the `A'
flag is active, then the alternate-character generated by this scan code
is listed next.  Furthermore, if the `L' or `S' flag is active, then the shifted
alternate-character is listed after that.  If the `C' flag is also active,
then the alternate-control-character is listed next.  Finally, if the `C' and
`L' or `C' and `S' flags are also active, then the shifted alternate-control-character
is listed. </li>
</ul>
</blockquote>
<p>
 The `R' flag does not actually refer to a modifier key.  Instead,
it is used to distinguish the scan code which is given the special pseudo-designation
of <i>carriage return</i> key.  Typically, this mask appears solo and only the
two fields for control-M and control-C follow.  This flag may be a throwback
to an earlier time or may be specially interpreted by the low-level keyboard
driver, but its purpose is otherwise enigmatic. <p>
Recalling the example from
above, the following fields can be identified: <p>
<blockquote><br>
<pre>scan 0x00: -AC-L  "a" "A" "^A" "^A" ca c7 "^A" "^A"
</pre></blockquote>
<p>
<blockquote> 
<ul>
&nbsp;<li>Lower-case `a' is generated when no modifiers are active. </li>&#183;&nbsp;<li>Upper-case `A' is generated
when <i>shift</i> or <i>alpha-lock</i> are active. </li>&nbsp;<li>Control-A is generated when <i>control</i> is
active. </li>&nbsp;<li>Control-A is generated when <i>control</i> and <i>shift</i> are active. </li>&#183;&nbsp;<li>The character
represented by the hexadecimal code 0xca is generated when <i>alternate</i> is
active. </li>&nbsp;<li>The character represented by 0xc7 is generated when <i>alternate</i> and
<i>shift</i> (or <i>alpha-lock</i>) are active. </li>&nbsp;<li>Control-A is generated when <i>alternate</i> and
<i>control</i> are active. </li>&nbsp;<li>Control-A is generated when <i>alternate, control</i> and <i>shift</i>
(or <i>alpha-lock</i>) are active. </li>
</ul>
</blockquote>
<p>
 The notation used to represent a particular
generated character varies. <p>
<blockquote> 
<ul>
&nbsp;<li>Printable <font size='-1'>ASCII</font>
 characters are quoted, as in
"x" or "X". </li>&nbsp;<li>Control-characters are quoted and prefixed with `^', as in "^X". </li>&#183;&nbsp;
<li>Characters with values greater than 127 (0x7f) are displayed as hexadecimal
values without the `0x' prefix. </li>&nbsp;<li>Characters in a non-<font size='-1'>ASCII</font>
 character set (such
as `Symbol') are displayed as two hexadecimal numbers separated by a slash,
as in `01/4a'.  The first number is the character set's identification code
(such as `01' for the `Symbol' set), and the second number is the value of
the generated character. </li>&nbsp;<li>Non-printing special function characters are displayed
with the function's common name enclosed in brackets, as in `[page up]' or
`[F4]'. </li>&nbsp;<li>If the binding represents a key sequence rather than a single character,
then the sequence's identification number is enclosed in braces, as in `{seq#3}'.
</li>
</ul>
</blockquote>
<p>
 Recalling a few examples from above, the following interpretations can
be made: <p>
<blockquote><br>
<pre>scan 0x07: -AC-L  "x" "X" "^X" "^X" 01/b4 01/ce "^X" "^X"
scan 0x3e: -----  [F4]
scan 0x4a: -----  [page up]
scan 0x60: -----  {seq#3}
</pre></blockquote>
<p>
<blockquote> 
<ul>
&nbsp;<li>"x" and "X" are printable <font size='-1'>ASCII</font>
 characters. </li>&#183;&nbsp;<li>"^X" is a control-character. </li>&#183;&nbsp;
<li>`01/b4' and `01/ce' represent the character codes 0xb4 and 0xce in the `Symbol'
character set. </li>&nbsp;<li>Scan code 0x3e generates function-key `F4', and scan code 0x4a
generates function-key `page up'. </li>&nbsp;<li>Scan code 0x60 is bound to key sequence #3.
</li>
</ul>
</blockquote>
<p>
 Finally, if a scan code is not bound to any characters, then it is annotated
with the label `not-bound', as with example scan code 0x68 from above. 
<h2><a name='sect19' href='#toc19'>Sequences</a></h2>
A
scan code (modified and unmodified) can be bound to a key sequence rather
than generating a single character or acting as a modifier.  When it is
bound to a key sequence, a series of character invocations and modifier
actions are automatically generated rather than a single keystroke. <p>
Each
mapping may contain zero or more key sequence records.  The title <font size='-1'>`SEQUENCES'</font>

is printed along with the count of sequence records which follow.  For example:
<p>
<blockquote><br>
<pre>SEQUENCES [3]
sequence 0: "f" "o" "o"
sequence 1: {alternate} "b" "a" "r" {unmodify}
sequence 2: [home] "b" "a" "z"
</pre></blockquote>
<p>
The notation used to represent the sequence of generated characters is
identical to the notation already described in the <i>Characters</i> section above,
with the exception that modifier actions may be interposed between generated
characters.  Such modifier actions are represented by the modifier's name
enclosed in braces.  The special name `{unmodify}' indicates the release of
the modifier keys. <p>
Thus, the sequences in the above example can be interpreted
as follows: <p>
<blockquote> 
<ul>
&nbsp;<li>Sequence&nbsp;#0 generates `foo'. </li>&#183;&nbsp;<li>Sequence&nbsp;#1 invokes the <i>alternate</i>
modifier, generates `bar', and then releases <i>alternate.</i> </li>&nbsp;<li>Sequence&nbsp;#2 invokes
the <i>home</i> key and then generates `baz'.  In a text editor, this would probably
result in `baz' being prepended to the line of text on which the cursor resides.
</li>
</ul>
</blockquote>
<p>
 
<h2><a name='sect20' href='#toc20'>Special Keys</a></h2>
Certain keyboards feature keys which perform some type of
special purpose function rather than generating a character or acting as
a modifier.  For instance, Apple keyboards often contain a <i>power</i> key, and
<font size='-1'>NeXT</font>
 keyboards have historically featured screen brightness and volume
control keys. <p>
Each mapping may contain zero or more special-key records which
associate hardware scan codes with such special purpose functions.  The
title <font size='-1'>`SPECIALS'</font>
 is printed along with the count of records which follow.
 For each record, the special function's name is printed along with a list
of scan codes, in hexadecimal format, which are bound to that function.
 For example: <p>
<blockquote><br>
<pre>SPECIALS [6]
alpha-lock: 0x39
brightness-down: 0x79
brightness-up: 0x74
power: 0x7f
sound-down: 0x77
sound-up: 0x73
</pre></blockquote>

<h2><a name='sect21' href='#toc21'>Files</a></h2>

<dl>

<dt>*.keymapping</dt>
<dd>A key mapping file which precisely defines the relationship
of all hardware-specific keyboard scan-codes with their associated functionality.
</dd>

<dt>*.keyboard</dt>
<dd>A file describing the physical layout of keys on a particular
type of keyboard.  Each `key' token in this file defines the position and
shape of the key on the keyboard, as well as the associated scan code which
that key generates.  A <i>.keymapping</i> file, on the other hand, defines the characters
which are generated by a particular scan code depending upon the state
of the various modifier keys (such as <i>shift,</i> <i>control,</i> etc.).  The `interface'
and `handler_id' values from a <i>.keymapping</i> file are matched against those
in each <i>.keyboard</i> file in order to associate a particular <i>.keyboard</i> file
with a key mapping.  Various <font size='-1'>GUI</font>
 programs use the <i>.keyboard</i> file to display
a visual representation of a keyboard for the user.  Since these files are
just plain text, they can be easily viewed and interpreted without the
aid of a specialized program, thus <i>dumpkeymap</i> leaves these files alone.
</dd>
</dl>
<p>
/System/Library/Keyboards <br>
/Network/Library/Keyboards <br>
/Local/Library/Keyboards <br>
/Library/Keyboards <blockquote>Repositories for <i>.keymapping</i> and <i>.keyboard</i> files for MacOS/X,
Darwin, and MacOS/X Server. </blockquote>
<p>
/NextLibrary/Keyboards <br>
/LocalLibrary/Keyboards <blockquote>Repositories for <i>.keymapping</i> and <i>.keyboard</i> files
for OpenStep and NextStep. </blockquote>

<dl>

<dt>$(HOME)/Library/Keyboards</dt>
<dd>Repository for personal
<i>.keymapping</i> and <i>.keyboard</i> files. </dd>
</dl>

<h2><a name='sect22' href='#toc22'>Diganostics</a></h2>
The following diagnostic messages
may be issued to the standard error stream. 
<dl>

<dt>Unrecognized option. </dt>
<dd>  An unrecognized
option was specified on the command-line.  Invoke <i>dumpkeymap</i> with the <b>--help</b>
option to view a list of valid options. </dd>

<dt>Insufficient data in keymapping
data stream. </dt>
<dd>  The key mapping file or data stream is corrupt.  Either the
file has been incorrectly truncated or a field, such as those which indicates
the number of variable records which follow, contains a corrupt value. </dd>
</dl>
<p>
The
following diagnostic messages have significance only when trying to print
<i>.keymapping</i> files mentioned on the command-line. 
<dl>

<dt>Bad magic number. </dt>
<dd>  The mentioned
file is not a <i>.keymapping</i> file.  The file's content does not start with the
string `KYM1'. </dd>

<dt>Unable to open key mapping file. </dt>
<dd>  The call to fopen() failed;
probably because the specified path is invalid or <i>dumpkeymap</i> does not have
permission to read the file. </dd>

<dt>Unable to determine key mapping file size. </dt>
<dd>
 The call to fstat() failed, thus memory can not be allocated for loading
the file. </dd>

<dt>Unable to read key mapping file. </dt>
<dd>  The call to fread() failed. </dd>
</dl>
<p>
The
following diagnostic messages have significance only when trying to print
the currently active key mapping when no <i>.keymapping</i> files have been mentioned
on the command-line. 
<dl>

<dt>Unable to open event status driver. </dt>
<dd>  The call to NXOpenEventStatus()
failed. </dd>

<dt>Bad key mapping length. </dt>
<dd>  The call to NXKeyMappingLength() returned
a bogus value. </dd>

<dt>Unable to get current key mapping. </dt>
<dd>  The call to NXGetKeyMapping()
failed. </dd>
</dl>
<p>
The following diagnostic messages have significance only when using
<i>dumpkeymap</i> on a non-Apple/<font size='-1'>NeXT</font>
 platform. 
<dl>

<dt>Must specify at least one .keymapping
file. </dt>
<dd>  No <i>.keymapping</i> files were mentioned on the command-line.  On non-Apple/<font size='-1'>NeXT</font>

platforms, there is no concept of a currently active <i>.keymapping</i> file, so
at least one file must be mentioned on the command-line. </dd>
</dl>

<h2><a name='sect23' href='#toc23'>Author</a></h2>
Eric Sunshine
&lt;sunshine@sunshineco.com&gt; wrote <i>dumpkeymap</i> and this document, the <i>dumpkeymap
user's manual.</i> Both <i>dumpkeymap</i> and this document are copyright &copy;1999,2000
by Eric Sunshine &lt;sunshine@sunshineco.com&gt;.  All rights reserved. <p>
The implementation
of <i>dumpkeymap</i> is based upon information gathered on September 3, 1997 by
Eric Sunshine &lt;sunshine@sunshineco.com&gt; and Paul S. McCarthy &lt;zarnuk@zarnuk.com&gt;
during an effort to reverse engineer the format of the <font size='-1'>NeXT</font>
 <i>.keymapping</i>
file. <p>
 Version 4 -- 1 December 2000   <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Options</a></li>
<li><a name='toc4' href='#sect4'>Key Mapping Description</a></li>
<li><a name='toc5' href='#sect5'>Types and Data</a></li>
<li><a name='toc6' href='#sect6'>Key Mapping File and Device Mapping</a></li>
<li><a name='toc7' href='#sect7'>Key Mapping</a></li>
<li><a name='toc8' href='#sect8'>Modifier Group</a></li>
<li><a name='toc9' href='#sect9'>Scan Group</a></li>
<li><a name='toc10' href='#sect10'>Character</a></li>
<li><a name='toc11' href='#sect11'>Sequence</a></li>
<li><a name='toc12' href='#sect12'>Special Key</a></li>
<li><a name='toc13' href='#sect13'>Output</a></li>
<li><a name='toc14' href='#sect14'>Conventions</a></li>
<li><a name='toc15' href='#sect15'>Key Mapping Source</a></li>
<li><a name='toc16' href='#sect16'>Device Information</a></li>
<li><a name='toc17' href='#sect17'>Modifiers</a></li>
<li><a name='toc18' href='#sect18'>Characters</a></li>
<li><a name='toc19' href='#sect19'>Sequences</a></li>
<li><a name='toc20' href='#sect20'>Special Keys</a></li>
<li><a name='toc21' href='#sect21'>Files</a></li>
<li><a name='toc22' href='#sect22'>Diganostics</a></li>
<li><a name='toc23' href='#sect23'>Author</a></li>
</ul>
</body>
</html>
